# 整洁架构精粹

## 1.介绍

让软件能用很容易，但是将软件架构设计好却很困难。好的软件架构可以大大节省软件项目构建与维护的人力成本。让每次变更都短小简单，易于实施，并且避免缺陷，用最小的成本，最大程度地满足功能性和灵活性的要求。

> 你肯定经历过这样的情境：某个系统因为其组件错综复杂，相互耦合紧密，而导致不管多么小的改动都需要数周的恶战才能完成。又或是某个系统中到处充满了腐朽的设计和连篇累牍的恶心代码，处处都是障碍。再或者，你有没有见过哪个系统的设计如此之差，让整个团队的士气低落，客户天天痛苦，项目经理们手足无措？你有没有见过某个软件系统因其架构腐朽不堪而导致团队流失，部门解散，甚至公司倒闭？作为一名程序员，你在编程时体会过那种生不如死的感觉吗?

### 1.1 设计与架构到底是什么?

“架构”这个词往往使用于“高层级”的讨论中，而“设计”一词，往往用来指代具体的系统底层组织结构和实现的细节。但是，从系统架角度来看，这样的区分是根本不成立的。

以房屋设计图为例，它既包含了房屋用途、形状、外观、布局等高层决策，又包含插座、开关、壁炉、热水器的具体安装位置和规格。

在软件设计中，高层决策和细节设计都是整体设计中的一部分，他们共同构成了一个软件系统。

#### 1.1.1 软件架构的目标

软件架构的终极目标，是最小化构建和维护软件系统的人力需求。

一个软件架构的优劣，可以用它满足用户需求所需要的成本来衡量。如果该成本很低，并且在系统的整个生命周期内一直都能维持这样的低成本，那么这个系统的设计就是优秀的。如果该系统的每次发布都会提升下一次变更的成本，那么这个设计就很差。

#### 1.1.2 案例分析

  软件工程师数量持续增长：![](.\image\figure_1.1_engineer_staff_growth.PNG)

相同的发布周期，产出的代码行数变化：

![](.\image\figure_1.2_engineer_productivity.PNG)

每一行代码所耗费的成本：

![](.\image\figure_1.3_cost_of_loc.PNG)

工程师生产效率的变化：

![](.\image\figure_1.4_productivity_by_release.PNG)

研发团队工资支出：

![](.\image\figure_1.5_engineer_payroll.PNG)

无论是工程师还是管理层都意识到系统存在严重问题，但是问题究竟在哪里呢？

#### 1.1.3 反思

从龟兔赛跑的故事，我们可以得知：
1. 慢但是稳，是成功的秘诀。
2. 该比赛并不是拼谁开始跑得快，也不是拼谁更有力气的。
3. 心态越急，反而跑得越慢。

这个故事本身揭露的是过度自信的愚蠢行为。

现在的软件研发工程师都有点过于自信。他们确实不会偷懒，但是他们真正偷懒的地方在于——持续低估那些好的、良好设计的、整洁的代码的重要性。

一个常见的借口就是：“先上线，后面再改...”,其实谁都知道，永远也不可能有“后面再改”的机会。

一个更加错误的观点是，写不经思考得些烂代码比写经过深思熟虑的代码效率更高。

软件开发的一个核心特点：要想走得快，就要走得稳。

开发团队需要改变自身的观念，从过度自信的兔子模式转变回来，严肃认真地对待软件质量。

### 1.2 软件的两种价值

所有的软件系统都蕴含两种价值：行为价值和结构价值。

#### 1.2.1 行为价值

软件的行为价值是软件能够满足业务需求的能力，是其最直观的价值维度。

#### 1.2.2 结构价值

软件的架构就是软件的结构价值。结构价值和软件中的“软”字密切相关，也是软件能够适应变化的能力。

#### 1.2.3 哪个价值更重要

业务部门通常认为系统正常工作很重要。系统开发人员常常也就跟随采取了这种态度。但是这种态度是错误的。

对于开发团队来说，结构价值更重要。

因为：

- 如果给你一个软件，它能完美地满足业务需求，但是却难以改动，那么当需求变化时就难以适应，进而无法满足将来的业务需求。最终，这个软件将变得毫无用处。
- 如果给你一个软件，虽然一开始不满足业务需求，但是易于改动，那么我们可以将它该来满足业务需求，并且让它有能力满足将来的业务需求变化。最终，这个软件将持续提供价值。

如果你问业务部门，是否想要能够变更需求，他们的回答一般是肯定的，而且他们会增加一句：完成现在的功能比实现未来的灵活度更重要。但讽刺的是，如果事后业务部门提出了一项变更需求，而你的预估工作量大大超出他们的预期，这帮家伙通常会对你放任系统混乱到无法变更的状态而勃然大怒。

#### 1.2.4 艾森豪威尔的矩阵

“我有两种问题，重要的和紧急的。重要的通常不紧急，紧急的通常不重要。”

![](.\image\figure_2.1_importance_matrix.PNG)

任务的优先级：

1. 紧急且重要
2. 不紧急但重要
3. 紧急不重要
4. 不紧急不重要

软件的第一种价值，行为价值，就是紧急但不重要的，排第3位。

软件的第二种价值，结构价值，就是重要但是不紧急的，排第2位。

通常，软件开发人员将行为价值放到了第1位，这使他们忽略了架构对于系统的重要性。

#### 1.2.5 为了架构的重要性而战

开发团队必须从公司长远利益出发与其他部门抗争。软件系统的可维护性需要由开发团队来保护，这是开发人员角色的一部分，也是你职责中不可缺少的一部分。

软件架构师这一职责本身就应更关注系统的整体结构，而不是具体的功能和系统行为的实现，软件架构师必须创建出一个可以让功能实现起来更容易、修改起来更简单、扩展起来更轻松的软件架构。通过结构使得软件具备适应变化的能力，从而为客户持续带来价值。

## 2.从软件的基石讲起

#### 2.1 结构化编程（structured programming）

1. 结构化编程中使用直接控制的方式来构建程序。
2. 结构化编程中只使用顺序、选择、循环三种结构来构建程序。
3. 结构化编程中，main函数依赖于高抽象层次的函数，高抽象层次的函数依赖于低抽象层次的函数。
4. 结构化程序中，功能模块被分解成多个函数，函数可以进一步细分，函数都是可以被验证的。
5. 结构化编程方法提供了单元测试的基础。

#### 2.1 面向对象编程（objected oriented programming）

面向对象编程中使用间接控制的方式来构建程序。

关于面向对象（OO）的常见定义有下面3种，但是都不是很准确：

- 面向对象就是数据和函数的结合；
- 面向对象是一种为真实世界进行建模的方式；
- 面向对象就是封装、继承和多态；

封装、继承、多态并不是OO程序设计语言所独有的，比如C语言中有结构体、头文件、对“文件”的抽象也有体现。

在结构化的程序形成了高抽象层次的函数对低抽象层次函数的依赖，多态使得这种依赖方向发生了反转。

Uncle Bob 认为：面向对象就是一种通过多态，可以完全控制源代码依赖方向的能力。

#### 2.1 函数式编程（functional programming）

函数式编程中，将可修改变量和不可修改变量分离，函数的行为只与入参有关。

通过使用不可修改变量，函数式编程可以避免资源竞争、死锁等并发问题。

“事件源”机制，将交易的过程而不是结果记录下来，当需要使用结果时进行实时计算，完全避免事务。

函数式编程通过赋值的方式来构建程序。

## 3.设计原则

### 3.1 单一职责原则（SRP)

很多人认为SRP是：

> 每个模块都应该只做一件事。

即确保一个函数只完成一个功能，但这只是一个面向底层实现细节的设计原则，并不是全部。

我们曾经这样描述 SRP ：

> 任何一个软件模块都应该有且仅有一个被修改的原因。

通常软件系统的用户就是该设计原则中所指的“被修改的原因”，那么，我们也可以这样描述 SRP：

> 任何一个软件模块都应该只对一个用户（User）或系统利益相关者（Stakeholder）负责。

如果把“用户”和 “系统利益相关者”称为行为者（actor）对于 SRP 的最终描述就变成了：

> 任何一个软件模块都应该只对某一类Actor负责。

那么，上文中提到的“软件模块”最简单的定义就是指一个源代码文件。然而，有些情况下，“软件模块”指的就是一组紧密相关的函数和数据结构。

在这里，“相关”这个词实际上就隐含了 SRP 这一原则。代码与数据就是靠着与某一类行为者的相关性被组合在一起的。

### 3.2 开闭原则（OCP）

开闭原则认为：

> 设计良好的计算机软件应该易于扩展，同时抗拒修改。

其实这也是我们研究软件架构的根本目的。如果对原始需求的小小延伸就需要对原有的软件系统进行大幅修改，那么这个系统的架构设计显然是失败的。

尽管大部分软件设计师都已经认可了 OCP 是设计类与模块时的重要原则，但是在软件架构层面，这项原则的意义则更为重大。

OCP 是我们进行系统架构设计的主导原则，其主要目标是让系统易于扩展，同时限制其每次被修改所影响的范围。实现方式是通过将系统划分为一系列组件，并且将这些组件间的依赖关系按层次结构进行组织，使得高阶组件不会因低阶组件被修改而受到影响。

### 3.3 里氏替换原则（LSP）

1988 年，Barbara Liskov 在描述如何定义子类型时写下了这样一段话：

> 这里需要的是一种可替换性：如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作 T 类型的程序 P 在用 o2 替换 o1 时行为保持不变，我们就可以将 S 称为 T 的子类型。

正方形/长方形问题是个著名的违反 LSP 的设计案例。

![](.\image\figure_9.2_rectangle.PNG)

在这个案例中，Square 类并不是 Rectangle 类的子类型，因为 Rectangle 类的高和宽可以分别修改，而 Square 类的高和宽则必须一同修改。由于 User 类 始终认为自己在操作 Rectangle 类，因此会带来一些混淆。例如在下面的代码中：

```java
Rectangle r = …
r.setW(5);
r.setH(2);
assert(r.area() == 10);
```

很显然，如果上述代码在…处返回的是 Square 类，则最后的这个 assert 是不会成立的。

如果想要防范这种违反 LSP 的行为，唯一的办法就是在 user 类中增加用于区分 Rectangle 和 Square 的检测逻辑（例如增加 if 语句）。但这样一来，user 为的行为又将依赖于它所使用的类，这两个类就不能互相替换了。

LSP 可以且应该被应用于软件架构层面，因为一旦违背了可替换也该系统架构就不得不为此增添大量复杂的应对机制。

### 3.4 接口隔离原则（ISP）

> 子类不需要实现它不需要依赖的方法，即接口定义的粒度应该足够小

“接口隔离原则（ISP）”这个名字来下图所示的这种软件结构。

![](.\image\figure_10.1_isp.PNG)

我们假设这里的 User1 只需要使用 op1，User2 只需要使用 op2，User3 只需要使用 op3。

在这种情况下，那么很明显，User1 虽然不需要调用 op2、op3，但在源代码层次上也与它们形成依赖关系。

这个问题可以通过将不同的操作隔离成接口来解决，如下图所示。那么现在 User1 的源代码会依赖于 U1Ops 和 op1，但不会依赖于 OPS。![](.\image\figure_10.2_isp.PNG)

任何层次的软件设计如果依赖了它并不需要的东西，就会带来意料之外的麻烦。

### 3.5 依赖反转原则（DIP）

> 抽象程度低的模块应该依赖于抽象程度高的模块，而不是反之。
>
> - 高层次的模块不应依赖低层次的模块，他们都应该依赖于抽象。
> - 抽象不应该依赖于具体，具体应该依赖于抽象。

依赖反转原则（DIP）主要想告诉我们的是，如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而用具体实现。

也就是说，在 Java 这类静态类型的编程语言中，在使用 use、import、include 这些语句时应该只引用那些包含接口、抽象类或者其他抽象类型声明的源文件，不应该引用任何具体实现。

严格执行DIP是不现实的，例如，Java 中的 String 类就是这样一个具体实现。但 String 类本身是非常稳定的，因为这个类被修改的情况是非常罕见的。

同理，在应用 DIP 时，我们也不必考虑稳定的操作系统或者平台设施。

我们主要关注的是软件系统内部那些会经常变动的具体实现模块。

如果想要在软件架构设计上追求稳定，就必须多使用稳定的抽象接口，少依赖多变的具体实现。

下面，我们将该设计原则归结为以下几条具体的编码守则：

- 应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。
- 不要在具体实现类上创建衍生类。
- 不要覆盖（override）包含具体实现的函数。
- 应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字。

## 4.组件原则

### 4.1 组件

组件（component）是软件的最小发布单元。

### 4.2 组件的聚合度

哪一个功能应该属于哪一个组件，是软件架构中要做的重要决策。组件的聚合度由一些列的指导原则来确定。

#### 4.2.1 重用与发布等价原则（REP）

定义：组件重用的粒度就是组件发布的粒度。

重用与发布等价原则是显而易见的，因为如果不能独立发布的功能，就无法被其他组件所重用。

#### 4.2.2 共同关闭原则（CCP）

定义：因同一原因，在同一时间发生变化的功能应该放入同一组件，反之则应放入不同组件。

共同关闭原则是单一职责原则和开闭原则在组件层面的体现。

#### 4.2.3 同等重用原则（CRP）

定义：不应强迫组件的使用者依赖起不需要使用的功能。

同等重用原则是接口隔离原则在组件层面的体现。

#### 4.2.4 结论

上述三种原则，既有相互包含，又有相互排斥，三者的平衡始终是动态的。

### 4.3 组件的耦合度

#### 4.3.1 非循环依赖原则（ADP）

定义：禁止组件之间形成循环依赖关系

解决之道：1. 使用依赖反转原则；2.提取公共的依赖组件；

#### 4.3.2 稳定依赖原则（SDP）

定义：按照稳定性的方向进行依赖，既不稳定组件应当依赖于稳定的组件。

稳定性的本意是难以变化，对于软件的组件，稳定性高意味着改变一个组件会使得大量依赖组件也发生变化，因而导致很大的工作量。

稳定性计算方法：

FI：依赖于本组件的组件数量；FO：本组件依赖的组件数量；

不稳定性：I=FO/(FO+FI)

I=0意味着最稳定，I=1意味着最不稳定。

![](.\image\figure_14.7_example.PNG)

上例中，模块Cc的FI=3，FO=1，所以其稳定性为: 1/(1+3)=1/4

一个软件不可能所有组件都是稳定的，一个健康的系统是由稳定的组件和不稳定的组件共同构成的。

#### 4.3.3 稳定抽象原则（SAP）

定义：越抽象的组件越稳定，越稳定的组件也越抽象。

在一个系统中，抽象等级高的概念应该放在稳定性高的组件中实现。举例，如果一个组件是稳定的，那么这个组件中应该由接口、抽象类构成。

一个组件的抽象程度可以使用接口和抽象类所占的比例来衡量。

### 5.架构

#### 5.1什么是架构
软件架构定义（IEEE 1471）：软件架构是软件组成模块的基础组织方式，组件之间的关系，组件的环境，以及指导软件设计和进化的基本原则。

软件架构定义（Uncle Bob）：软件架构的实质就是规划如何将系统切分成组件，安排好组件之间的依赖关系和通信方式。

软件架构师是能力最强的程序员。只有亲自承受设计不佳带来的痛苦，才不会迷失正确设计的方向。

软件架构的的策略就是为将来的变化留下尽可能多的选项。

软件架构的目标就是最小化开发、部署、运维、维护的成本。

软件的架构的目标和软件系统当前的功能是否能符合业务需求关系关系不大，但是和是否能支撑软件系统的开发、部署、运维和维护等全生命周期关系重大。

一个优秀的架构师会谨慎地区分实现细节和顶层原则，将顶层原则与实现细节解耦，从而使得实现细节有尽可能多的选项以应对将来发生的变化。

#### 5.2 独立性

一个好的架构必须支持：功能用例、运维、维护、开发和部署。

##### 5.2.1 功能用例

支持系统的功能用例是架构的首要考虑。

架构要能够直观地揭示系统的建设意图。

##### 5.2.2 运维

架构需要支持功能用例所需要的吞吐量和响应时间，容易地支持系统的水平扩展。

##### 5.2.3 开发

架构设计与康威定律匹配。

例如，如果有多个团队共同开发同一个系统，则架构应该支持每一个团队负责一个模块。

##### 5.2.4 部署

架构设计需要支持软件系统随时可部署。

好的架构设计不会导致应用依赖太多配置文件，需要太多手工操作才能进行部署。

##### 5.2.5 为将来的变化留有余地

好的架构需要艰难的在上述各种考虑之间寻找一种平衡。虽然，一开始可能由于还没有踩坑而无法拿捏到位，但是总有一些基本原则是在一开始就可以实施的。

##### 5.2.6 分层解耦

- 解耦用例：根据需求用例来拆分系统是最自然的一种方式。
- 解耦运维模式：根据需求用例拆分同样也导致各个模块的运维模式差异，例如“微服务”的组件。
- 解耦开发：如果系统模块之家是通过接口来约束的，那么各模块的开发就是独立的。
- 解耦部署：如果按照需求用例拆分恰当，则系统模块之间可以独立部署。

#### 5.3 边界：在模块之间划线

软件架构是边界划分的艺术。边界就是将一个软件系统划分成多个模块的“线”，约束模块之间的约束关系和方式。

软件架构的目标是尽可能多为将来的变化留有余地，但是要避免过早决策--那些和当前需求用例无关的决策。

##### 5.3.1 P公司的故事

- P公司研发了一款倍受欢迎单机版的软件；
- 为了应对将来可能将软件部署到Server Farm上，他们将软件拆分成3个模块，但研发过程仍然在单机进行；
- Server Farm从来没有出现，软件始终是运行在单机环境，模块之间的交互却使得软件的变更异常复杂；

##### 5.3.2 Fitness的故事

- 在数据访问层增加接口，因此在设计之初不用考虑数据库，后来发现使用内存和磁盘就足够了；

##### 5.3.3 何时何地划线

相对的，在重要的内容和不重要的内容之间划线。

不应该认为数据访问逻辑是核心业务逻辑，因而数据访问层和业务层之间应该有一条线。数据访问接口应该属于业务层，而其具体实现应该属于数据访问层。

一个基本原则：IO与GUI细节与业务核心逻辑是无关的。

##### 5.3.4 插件式架构

软件开发技术的发展史就是如何采用适当的插件来建立可伸缩、可维护的软件架构的过程。

插件式架构，就是指除系统的核心业务逻辑部分外，其余部分都是独立的可以替代的插件。核心业务逻辑的变化会影响插件，而插件的变化不会影响核心业务逻辑。

#### 5.4 边界解剖学

软件架构是由于软件的组件和分割组件的边界所定义的，边界存在多种形式。

##### 5.4.1 跨越边界

在运行时，总是存在边界一边的功能需要调用边界另外一边的功能的情况，这就是跨越边界。

要想处理好跨越边界，就要先处理好边界两边源代码的依赖。

##### 5.4.2 单体应用

单体应用的边界不是显而易见的，往往只是对于函数和数据分离的约定，但是依然是存在且有意义的。

单体应用中通常需要依赖多态来反转对低抽象层次对象的直接引用，这也是面向对象程序设计语言流行的原因。

##### 5.4.3 可部署组件

单个的可部署组件仍然可以看做是一个单体应用，组件之间的交互仍然是通过函数完成的，但是通常没有多态。

##### 5.4.4 进程

如果组件以独立进程的方式运行，进程间依赖仍然需要考虑单向依赖--具体依赖于抽象。

##### 5.4.5 服务

服务是最强的边界。服务是一个独立的进程，但是其存在与具体的物理位置无关。服务之间的交互只能通过网络完成。

#### 5.5 原则与层级
计算机程序就是一系列描述输入如何被转换成输出的原则。原则通常能够被细分为更加细节的原则。
###### 5.5.1 层级

原则层级就是与输入输出的距离，距离输入输出越远则层级越高。

#### 5.6 业务规则

业务规则就是业务的基本原则，是软件系统存在的根本原因。

对于商业软件来说，我们通常将影响“钱”的规则称为核心业务规则。

##### 5.6.1 业务实体

实体是包含了少量核心业务逻辑和核心业务数据的对象。实体中包含了核心业务数据或者获取核心业务数据的方法。实体的接口方法实现了核心业务逻辑对于核心业务数据的操作。

##### 5.6.2 业务用例

业务用例是对业务自动化过程的描述。业务用例定义了输入、输出和处理步骤。业务用例也描述业务逻辑，但通常不是最核心的业务逻辑。

可以认为，业务用例描述了业务实体的接口是被如何使用的。

##### 5.6.3 请求与响应模型

用例的输入输出数据不应该依赖于具体的实现技术，例如HTML和SQL。

#### 5.7 架构的主题

软件架构是用于支持系统用例实现的结构，和具体的框架无关，具体的框架只是工具。

##### 5.7.1 软件架构的目的

好的架构关注系统用例的实现。架构师可以在不依赖于框架、工具、环境的情况下用于支持业务用例的实现。

好的架构可以使得尽量多的决策延后实施。框架、数据库、环境、工具等都可以放到将来决定。

##### 5.7.2 框架只是工具

开发框架可以很强大也很有用，但是其本质只是工具，不应成为架构本身。架构师应该始终带着质疑的眼光来看待开发框架。

##### 5.7.3 可测试的架构

如果软件架构始终是围绕着业务用例的，那么依此构建的软件应该始终可测，因为测试不会依赖于服务器、数据库和运行环境。

#### 5.8 整洁架构

##### 5.8.1 整洁架构的特征

- **独立于框架**

​       架构不依赖于框架的功能和特性，这样才能真正把框架看做工具，不受框架的约束。

- **可测试**

  业务规则可以在没有UI、Web服务器、数据库和其他外部资源的情况下进行测试。

- **独立于UI**
  UI可以容易地进行改变，但是不影响系统的其他部分功能。
  
- **独立于数据库**
  业务规则不绑定与特定数据库和存储服务。
  
- **独立于外部服务**
  业务规则的实现和系统外部的服务与接口没有关系。

![](.\image\figure_22.1_clean_arch.PNG)

##### 5.8.2 依赖的原则

**源代码的依赖方向必须从外层指向内层，从低层级的原则指向高层级的原则。**

因此，内层的代码不应该拥有任何外层代码的信息。

**业务实体**

业务实体中蕴含中最核心的业务逻辑，它封装了高层级的原则，它是一个系统中最不可能变化的部分。

**业务用例**

业务用例中蕴含中业务场景相关的规则，业务用例层编排了来自于实体的数据流动，指导实体使用其核心业务规则实现核心业务逻辑。

**接口适配器**

接口适配器用于将数据从用户友好的格式转换为业务实体所需要的格式。在MVC模式中，Presenter、View、Controller都属于接口适配器。

接口适配器也用于将数据从业务实体转换到外部系统和存储需要的格式。比如Mapper、JPA等都属于接口适配器。

**框架和驱动**

框架与驱动是整洁架构的最外层，所有的最终细节都在这里体现。

**跨越边界**

如果存在违背依赖方向的跨边界调用，则我们使用依赖反转原则来解决。例如，如果用例层的代码需要调用视图层，则我们可以在用例层定义一个接口，让视图层来实现这个接口，再利用运行时多态来实现这种调用，同时避免错误的依赖方向。

**跨越边界的数据**

通常，能够跨越边界的数据都是简单的数据结构，比如简单的结构体，甚至是纯粹的参数。不能将业务实体对象或者数据库行作为数据对象在多个层次间传递。

![](.\image\figure_22.2_type_java_web_application.PNG)

#### 5.9 展示器和谦卑对象
##### 5.9.1 谦卑对象模式
谦卑对象模式最早用于单元测试。将被测行为分为两类：难以测试的行为属于谦卑组；容易测试的行为属于另外一组。

##### 5.9.2 展示器和视图
测试GUI时，我们可以利用谦卑对象模式将GUI分为难以测试的视图（View）和容易测试的展示器（Presenter）两部分。
展示器的职责是从应用程序中接受数据，然后按视图的需要将这些数据格式化，以便视图将其呈现在屏幕上。
视图除了加载视图模型所需要的值，不应该再做任何其他事情。所以我们才说视图是谦卑对象。

##### 5.9.3 可测性与架构
强大的可测性是衡量架构是否优秀的重要标准。谦卑对象模式是一个很好的例子。
我们将系统行为分割成可测试和不可测试两部分的过程也就定义了一种系统架构边界。

##### 5.9.4 数据库网关
我们将用例交互器（Interactor）与数据库交互的组件成为数据库网关（Database Gateway）。
数据库网关是一种谦卑对象，它封装了对于数据库的增、删、改、查接口，它不可测试，但是容易在测试时使用测试替身替代。

##### 5.9.5 数据隐射
ORM事实上压根就不存在，因为对象不是数据结构。用户看到的对象的共有函数，因而从用户角度看对象是一系列操作的集合，而不是简单的数据结构。
数据结构应该是一组可以公开访问的变量，其不包含任何行为信息。

##### 5.9.6 服务监听
与外部服务交互的服务监听器也是谦卑对象。

##### 5.9.7 总结
只要跨越系统架构边界，使用谦卑对象模式可以大幅提高系统的可测试性。

#### 5.10 不完全边界
##### 5.10.1 构建不完全边界
构建完整的架构边界成本极高，但是为了应对将来可能的需要，通常还是需要预留一个边界。这违背了YAGNI，但是架构师需要做这种预见性的设计。

##### 5.10.2 实现不完全边界的方法
1. 将系统分割成一系列可以独立编译、独立部署的组件之后，再将他们构建成一个组件。

2. 采用策略模式，Client访问的是由ServiceImpl实现的ServiceBoundary接口。

   ![](.\image\figure_24.1_strategy_pattern.PNG)

3. 采用门户模式，边界由Facade类定义，Facade背后是一系列Client不可见的函数列表。

![](.\image\figure_24.2_facade.PNG)

#### 5.11 服务：宏观与微观
##### 5.11.1 面向服务的架构
架构设计的任务就是找到高层策略与底层细节之间的边界，同时保证这些边界遵守依赖关系准则。
服务本身只是比函数调用更加高级、分割应用程序行为的一种方式。
用服务来隔离不同平台或者进程中的应用程序本身是一件重要的事情，但是服务本身并不能代表系统架构。

服务未必能够实现模块之间的解耦。例如，服务双方存在数据、接口定义的耦合。
服务并不是构建大型应用的唯一选择，单体应用也可以构建大型应用。

##### 5.11.2 总结
虽然服务化可能有助于提升系统的可扩展性和可研发性，但服务本身却并不能代表整个系统的架构设计。系统的架构是由系统内部的架构边界，以及边界之间的依赖关系所决定的，这与系统各组件之间的调用和通信方式无关。

#### 5.12 测试边界

##### 5.12.1 测试也是一种系统组件

从软件架构的角度来讲，所有的测试都是一样的，他们的存在是为了支持开发过程。

测试程序可以看做系统架构中最外圈的程序，他们始终向内依赖，而系统中没有依赖于他们的组件。

##### 5.12.2 可测试性设计

没有可测试性就会导致系统脆弱、僵化、难以更改。

如果一个系统功能的变更导致成百上千个测试失败，这种就是脆弱的测试问题。

要解决脆弱的测试问题，就要保证测试不依赖于多变的东西。例如，GUI是多变的，依赖于GUI的测试一定是脆弱的。

##### 5.12.3 测试专用API

可以为专门验证业务逻辑创建一个API，授予其超级用户权限，该API是用户界面到所用到的交互器与接口适配器的超集。

测试API可以将测试从应用程序中分离出来。

##### 5.12.4 结构性耦合

如果测试套件中针对每一个产品类都有一个测试类，每个产品函数都有一个测试函数，则测试套件与应用程序存在结构性耦合。

如果产品中的一个函数或者类发生变化，就必须对测试代码进行修改，从而导致测试是脆弱的。

测试专用API的作用就是将测试代码与应用程序解耦，这种设计也允许测试代码在不影响生产代码的情况下进行重构和演进。

##### 5.12.5 安全性

避免测试API被部署到生产环境，从而产生安全性问题。



### 6. 实现细节

#### 6.1 数据库只是实现细节

从系统架构的角度，数据库并不重要，因为它只是一个实现细节，在系统架构中不占据重要角色。

数据模型对于系统架构来说是很重要，但是数据库并不是数据模型，数据库只是底层的实现细节。

优秀的架构师是不会让实现细节污染整个系统架构的。

##### 6.1.1 关系型数据库

关系型数据库是一种非常优秀的数据存储与访问技术，但是它终究只是一种实现细节。

应用程序的用例不应该关心低层次的实现细节。

有些数据访问框架将数据行和数据表以对象的形式在系统内部传递，这种做法在系统架构上是错误的。

##### 6.1.2 为什么数据库系统如此流行

数据库流行的原因在于磁盘的访问速度太慢，特别是基于内容的检索。

#### 6.2 Web是实现细节

GUI只是一个实现细节，而Web是一种GUI，软件架构需要将这类细节与核心业务逻辑隔离开来。

#### 6.3 应用程序框架是实现细节

框架是一种不得不接受的依赖，但是请不要嫁给框架。

#### 6.4 总结

假设我们正在构建一个在线书店，需要实现一个用户查看订单状态的用例。

我可以考虑不同的代码设计和结构:

##### 6.4.1 按层封装

传统的水平分层架构将代码从技术角度进行分类。例如，常见的Web应用中，Web代码分为一层，业务逻辑分为一层，持久化分为一层。

例如，在Java中使用包来表示分层，上例中包含以下Java类：

- com.mycompany.myapp.web.OrdersController
- com.mycompany.myapp.service.OrderService
- com.mycompany.myapp.service.OrderServiceImpl
- com.mycompany.myapp.data.OrderRepository
- com.mycompany.myapp.data.JdbcOrderRepository

按层封装在项目初期很合适，但是随着软件规模的增加，我们就会发现3层并不够，需要进一步细化。

按层封装无法展现具体的业务领域信息，且导致不同系统的相似度很高。

##### 6.4.2 按功能封装

根据相关的功能、业务概念或者聚合根来切分，即垂直切分。在常见的实现中，所有类型都在同一个包中，包名以业务概念来命名。

按功能封装的一个好处就是很容易找到相关代码，因为包名就是业务概念的名称。

例如，上例中出现的Java类：

- com.mycompany.myapp.orders.OrdersController
- com.mycompany.myapp.orders.OrderService
- com.mycompany.myapp.orders.OrderServiceImpl
- com.mycompany.myapp.orders.OrderRepository
- com.mycompany.myapp.orders.JdbcOrderRepository

##### 6.4.3 端口和适配器

通过采用“端口和适配器”、“六边形架构”、“边界、控制器和实体”，我们可以创造出一个业务领域代码与具体实现细节隔离的架构。

这种架构下区分内部代码和外部代码。内部代码包含了所有领域概念，外部代码包含了与外界交互的部分。

这种架构下，只有外部代码能依赖内部代码，内部代码不能依赖外部代码。

##### 6.4.4 按组件封装

将“业务逻辑”与“持久化代码”合并在一起，形成一个可独立部署的单元，成为组件。

按组件封装的好处就是与某个业务功能相关的代码全部集中在一个组件中，有点类似于微服务架构。
