# 敏捷软件开发，原则、模式与实践

## 第I部分 敏捷开发

### 1. 敏捷实践

#### 1.1 敏捷宣言

我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。

由此我们建立了如下价值观：

**个体和互动**  高于  流程和工具
**工作的软件**  高于  详尽的文档
**客户合作**      高于  合同谈判
**响应变化**      高于  遵循计划

也就是说，尽管右项有其价值，我们更重视左项的价值。

**个体和互动高于流程和工具**

-   人是成功最重要的因素。如果没有强力参与者，好的流程也不能避免项目失败。
-   团队协作、沟通与互动比纯编码天赋更加重要。
-   工具很重要，但是过度地使用工具可能比缺乏工具更糟糕。
-   构建团队比构建工具和环境更加重要，因为好的团队会自己构建好的环境和工具。

**工作的软件高于详尽的文档**

- 文档是用于沟通的，过度的文档比没有文档更糟糕，因为文档难以和代码保持同步。
- 文档需要保持“重要”和“短小”：只包括全局的设计和架构，一二十页足够。
- 最好的文档就是系统的源代码，因为源代码不会撒谎。
- 除非文档很重要并且立即需要，否则不要写文档。

**客户合作高于合同谈判**

- 软件不是普通的产品，难于用普通的规格、时效和成本来制造。
- 频繁的客户反馈能才能保证软件项目的成功。
- 使用合同来约束开发过程是没有意义的，最好的契约是客户积极参与项目。

**响应变化高于遵循计划**

- 软件项目的成败取决于其适应变化的能力。
- 制定计划时，要确保计划足够灵活，以便应对需求和技术的变化。
- 商业环境会变化、客户需求会变化，这是不变的真理。
- 当团队获取到足够的知识后，一板一眼的计划方式往往不太重要。
- 只为未来两周做详细计划，为未来三个月做粗略计划，仅此而已。

#### 1.2 敏捷软件的12条原则

1. 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。
2. 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。
3. 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。
4. 业务人员和开发人员必须相互合作，项目中的每一天都不例外。
5. 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。
6. 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。
7. 可工作的软件是进度的首要度量标准。
8. 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。
9. 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。
10. 以简洁为本，它是极力减少不必要工作量的艺术。
11. 最好的架构、需求和设计出自自组织团队。
12. 团队定期地反思如何能提高成效，并依此调整自身的举止表现。

### 2.极限编程(XP)

#### 2.1极限编程实践

极限编程是最著名的敏捷软件开发方法。极限编程有一系列简单、独立的实践构成，这些实践相互配合才能发挥最大效用。

**1. 客户作为团队成员**

客户与开发紧密协作，共同为解决问题而努力。

在XP团队中，客户就是为需求定义优先级的人。

有时，客户是同一个公司的商业分析师和市场专员；有时，客户就是代表真正的用户的人；当然，有时候客户就是付钱的那个人。

但是，不管客户具体是谁，他们都是团队的一份子，并且为团队贡献。

客户离开发团队越近越好。如果实在找不到客户，一定要找一个愿意代表客户，并且愿意参与团队的人。

**2.用户故事**

我们不需要了解太过详细的需求内容，只需要了解到足够估算的程度就够了。

需求的特定细节可能随时变化，在距离上线很远时关注太多细节，很有可能产生浪费。

需求卡片是我们与客户达成的共识，是需求澄清过程中的助记词，客户根据其优先级和估算来确定计划。

估算基于我们与客户需求沟通过程中对细节的理解。

**3.短交付周期**

XP项目以每两周一轮迭代的方式交付一次可工作的软件。每轮迭代系统都要演示给干系人看，以获得反馈。

**迭代计划**

开发者通过测量前一轮迭代完成的用户故事给出当前迭代的预算。客户选择任何数量的用户故事放入当前迭代，只要它们的估算不超出预算。
一旦迭代启动，用户就承诺不改变用户故事和定义和优先级。开发者可以自由的把用户故事拆分成任务，根据符合技术和业务的优先级开发这些任务。

**发布计划**

发布计划是根据大约6轮迭代包含的用户故事制定的软件发布计划。发布计划代表一次较大的交付，通常该交付会被发布到生产环境中。
开发者通过上一次发布中完成的用户故事数量给出预算，客户可以挑选任意数量的用户故事加入当前发布计划，并决定这些故事的优先级。

**4.验收测试**

客户通过验收测试捕获用户故事细节。验收测试的编写要先于或者和用户故事的实现同步进行。
验收测试通常是一些脚本，可以自动化、重复执行。
验收测集在每次系统构建时都会运行，如果验收测试失败则构建失败。

**5.结对编程**

所有的产品代码都应该由结对的程序员在一台开发机器上共同完成。
结对的程序员一个掌握键盘，写代码，另一个人看着对方写，寻找错误和可以提高的地方。
结对的两人频繁进行角色切换，结对组合至少每天改变一次。
结对的做法将极大地促进知识在团队内的传播。

**6.测试驱动开发**

测试驱动开发是先写测试，再写实现的一种开发方式。所有产品代码都是让失败的单元测试通过而写。
测试驱动开发将激发开发人员解耦每一个模块，从而形成松耦合的设计。

**7.集体所有权**

团队中每一个人都有权修改任何模块中的代码。集体所有权并不意味着开发人员丧失专精领域，而是让开发人员不会被限制在自己的领域内。

**8.持续集成**

程序员每天会多次提交代码并进行集成。规则很简单：率先提交的人成功提交到代码库，其他人得合并本地代码后才能提交。集成过程中，所有测试都得通过，否则需要进行修复。

**9.可持续的开发速度**

软件项目不是短跑比赛，而是马拉松。为了快速完成开发，团队必须以一种可持续的速度前进。团队必须保持旺盛的精力和高度的警觉，必须有意识地保持稳定、适中的速度。

**10.开放的工作空间**

团队在一个开放的办公室一起工作，房间中有一些桌子，每张桌子上摆放着两三台工作电脑，每台工作电脑前都有两把椅子预备给结对编程的人员，墙壁上挂满了状态图表、任务分解表和UML图等。
所有人可以随时随地进行热烈的沟通。

**11.计划游戏**

计划游戏的本质是划分业务人员和开发人员之间的职责。业务人员决定特性的重要性，开发人员决定实现一个特性所花费的代价。
开发人员基于最近一次迭代或者发布的工作量估算出当前预算。客户挑选出的用户故事其总花销不超过预算。

**12.简单设计**

**考虑可行的最简单的事情**

XP团队总是尽可能寻找针对当前用户故事的最简单设计。

**YAGNI**

只有技术与基础设施真正需要时，才考虑引入，不会考虑提前预留。

**DRY**

极限编程人员不能容忍重复代码。消除重复的最好方法就是抽象。

**13.重构**

重构就是在不改变代码行为的前提下，进行小步改造从而改进系统结构。每一步改造都是微不足道的，但是所有改造叠加到一起，就能显著地改善系统的设计和架构。

**14.隐喻（metaphore）**

隐喻是整个系统连接在一起的全景图，是系统的愿景，它让所有独立模块的位置和形状一目了然。
隐喻是一个名称系统，名称提供了系统元素的词汇表，它有助于定义元素之间的关系。

### 3.计划
#### 3.1 初探
项目开始时，开发人员和客户会尽量识别出所有真正重要的用户故事。随着项目的进行，客户会不断地编写新的用户故事，这个过程会一直持续，直到项目结束。
开发人员共同对用户故事进行估算，估算是相对的，在故事卡片上写下“点数”来代表故事所花的相对时间。

**探究、分解和速度**
过大或者过小的用户故事都不太好估算。开发人员往往会低估哪些大的故事而高估那些小的故事。太大的用户故事应该拆分成更小的故事，太小的用户故事也应该和其他小的故事合并起来。

**速率**

速率是指每一个点数对应的实际天数。例如，速率是“每个点2天”，且有个故事的估算为4个点，那么这个故事就应该需要8天去实现。随着项目的进行，速率的测量会变得更加精确，因为我们可以衡量每个迭代完成的用户故事点数。

通过花费几天时间做一两个故事原型就足够了解团队的速率了，这种原型会议成为**探究**。

#### 3.2 发布计划

客户知道了速率，也就了解每个用户故事的开销、业务价值和优先级。所谓业务决策就是用户根据开销和优先级决定哪些用户故事能够带来最大的用户价值。

开发人员和客户商量好为了2-4个月中要完成的用户故事，以及他们之间的粗略顺序，从而形成粗略的发布计划。

由于初始的速率不准确，发布计划是可以调整的。

#### 3.3 迭代计划

迭代通常是2周时间。开发人员与客户一起选择他们想在一个迭代中完成的用户故事。用户故事不能超出当前的速率限制。

迭代中的用户故事完成顺序是一个技术决策。开发人员以最具技术意义的顺序开发用户故事。

一旦迭代开始，客户就不能改变迭代中的用户故事了。

迭代会在指定的时间结束，即便所有的用户故事都没有完成。迭代的速率会被计算出来，这个速率会被用来计划下轮迭代。

速率的反馈能帮助计划和团队同步，如果团队获得了经验和技巧，速率会适当提升。如果架构演进可以引导开发，那么速率也会上升。

#### 3.4 任务计划

迭代开始时，开发人员会把用户故事拆解成可以开发的任务，每个任务需要开发人员花费4-16个小时的时间。开发人员可以在客户的帮助下对这些用户故事进行分析，尽可能地列举所有的任务。

开发人员逐个认领他们感兴趣的任务，一旦认领，他们就会估算出一个任务点数。

开发人员可以认领不同领域的任务，选择不同的任务有利于知识的传播。

开发人员都清楚自己在上一个迭代中的完成的点数，这是他们的预算，没有人会选择超过自己的预算。

任务的选择一直持续到所有任务都被选完为止。如果所有的任务都已经被选完，人力仍然有剩余，则开发人员可以要求增加更多的用户故事；如果有任务无人认领，则开发人员可以要求撤出部分用户故事。

在迭代进行到一半的时候，团队会召开一次会议，根据用户故事完成的情况，团队可以调整用户故事的分配。如果故事无法重新分配，且预计无法完成，则需要知会用户。用户可以决定去掉一个任务或者故事。

#### 3.5 迭代

每轮迭代结束时，团队会给客户演示当前可运行的程序，让客户对程序的外观、感觉和性能进行评价。客户会把反馈写到新的用户故事中。

客户可以经常看到项目的进度，他们拥有所有项目的数据和控制权，可以按照他们意愿管理项目。

#### 3.6 小结

利益相关者可以经常、实实在在的看到项目进展，并且提供对项目的反馈。

开发人员看到合理的计划，因为计划是按照自己的估算做出的。

管理人员可以从迭代中获取数据，用于控制和管理项目。

利益相关者并不总是满意，但是可以通过这个过程控制团队以最小的代价获取最大的商业价值。

### 4.测试

写单元测试是一种验证行为，更是一种设计行为。同样，它更是一种编写文档的行为。写单元测试避免了相当多的反馈环，尤其是功能验证相关的反馈环。

#### 4.1 测试驱动开发

测试驱动开发所遵循的三个基本原则如下：

1. 除非能让失败的单元测试通过，否则不允许去编写任何的产品代码。
2. 只允许编写刚好能够导致失败的单元测试。
3. 只允许编写刚好能够使一个失败的单元测试通过的产品代码。

测试现行会迫使我们设计出可测试的程序，因为软件不得不和周边程序解耦，否则无法进行测试。

#### 4.2 验收测试

单元测试是必要的验证工具，但是不够充分。单元测试无法验证一个系统作为一个整体工作时的正确性。

验收测试是用来验证系统满足客户需求的黑盒测试。验收测试由不了解系统内部结构的客户或者QA编写。验收测试是关于一个特性（feature）的终极文档。程序员可以通过阅读验收测试来真正理解特性。

验收测试对于系统架构方面具有深远的影响，为了让系统具备可测性，就必须在高级别的架构层面进行系统解耦。自动化的验收测试，就如单元测试一样，可以促使开发人员在大的方面做出优良的架构决策。

#### 4.3 小结

测试套件运行起来越简单，运行就会越频繁。测试运行越频繁，就能越快的发现和测试偏离的情况。那么系统偏离正途时间就越短。

验证仅仅是写测试的好处之一，单元测试和验收测试都是一种文档形式。

测试最重要的好处就是对于设计和架构的影响，因为要具备可测性，则架构必须是松耦合的。

### 5. 重构

Martin Fowler对重构的定义是：

> 在不改变代码可观测行为的前提下，对代码进行修改，从而改进代码的内部结构。

为什么要改进代码的内部结构呢？因为代码模块有三个职责：

- 实现业务功能；
- 适应变化；
- 与代码阅读者进行沟通；

程序一旦变得易于理解，那么程序就会易于修改，从而可以适应变化。要想代码易于理解，就需要写整洁代码。

## 第II部分 敏捷设计

### 1 什么是敏捷设计

软件系统的源代码就是软件系统的设计，用于描述软件系统的文档和图示只是设计的附属物而不是设计本身。

#### 1.1 设计的坏味道

当软件出现以下症状时，说明软件正在腐败之中。

1、僵化（Rigidity）

僵化是指难以对软件进行改动，因为一处改动会导致有依赖关系的模块进行连锁改动。改动的模块越多则说明设计越僵化。

2、脆弱（Fragility）

脆弱是指在进行一处改动时，程序有许多地方都可能出现问题。出现问题的地方常常和改动的地方没有概念上的关联。要修正这些问题又会引入更多的问题。

3、顽固（Immobility）

顽固性是指设计中包含了对其他系统有用的部分，但是把这些部分从系统中分离出来所花费的努力和风险是巨大的。

4、粘性（Viscosity）

粘性有两个具体的表现：软件的粘性和环境的粘性。

当面临一处改动时，如果保持系统设计的改动方式比破坏系统设计的改动方式更难以应付，那就表明系统的粘性很高。

当开发环境迟钝、低效时，就会产生环境的粘性。例如，如果编译时间过长，则开发人员就倾向减少改动以避免提交，而不管设计是否能保持。

5、不必要的复杂性（Needless Complexity）

如果设计中包含了当前无用的元素，就说明它包含不必要的复杂性。

当开发人员预测需求的变化而预置应对变化的代码时，某些时候会带来回报，但是大部分时候都不会。但是此时设计所背负这些不会被用到的部分，会是软件变得复杂和难以理解。

6、不必要的重复（Needless Duplication）

代码以稍微不同的形式出现，表明开发人员忽视了抽象。使用抽象消除重复可以让系统变得易于理解和维护，但是往往被开发人员当做低优先级任务。

7、晦涩（Opacity）

晦涩是指模块难以理解。开发者需要站在代码阅读者的角度，重构代码，让代码易于理解。

#### 1.2 是什么导致软件的腐败

随着需求的变化，违背原有设计的改进逐步积累，设计也就随之出现臭味。

如果我们的设计因为持续、大量的需求变化而失败，表明我们的设计和实践本身是有缺陷的。我们必须找到一种方法，让设计适应这种变化，并且应用一些实践来防止设计腐坏。

#### 1.3 敏捷团队不允许软件腐坏

敏捷团队靠变化而充满活力。

敏捷团队保持系统的设计尽可能地简洁、简单，依赖于单元测试和验收侧四来保证设计的灵活性和易于修改。

利用这种灵活性，团队持续地改进设计，保证每轮迭代后系统设计都尽可能地和需求相吻合。

#### 1.4 敏捷开发人员如何知道要做什么？

敏捷开发人员基于以下四个方面的原因知道要做什么：

1、他们遵循敏捷实践去发现问题；

2、他们应用设计原则去诊断问题；

3、他们应用适当的设计模式去解决问题；

4、软件开发中这三个方面互相之间的作用就是设计；

#### 1.5 保持尽可能好的设计

敏捷开发人员致力于保持设计尽可能地恰当、整洁。这是一个持续的承诺。

敏捷开发人员对待软件设计的态度和外科医生对待消毒过程的态度是一样的。

作为敏捷开发人员，专业性要求我们不能容忍腐坏。

#### 1.6 敏捷设计的定义

敏捷的设计是一个持续应用原则、模式及实践来改进软件结构和可读性的过程。敏捷的设计致力于保持系统的设计尽可能的简洁、整洁和富有表现力。

### 2. 单一职责原则（SRP）

#### 2.1 什么是单一职责原则

定义：

>  一个类应该只有一个引起他变化的原因

如果一个类承担的职责过多，就等于将这些职责耦合到了一起。某一种职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到的破坏。

#### 2.2  什么是职责

职责就是“引起变化的原因“。如果有超过一个的动机去改变一个类，那么这个类就具有多种职责。

```java
public Interface Modem {
  public void Dial(String pno);
  public void Hangup();
  public void Send(char c);
  public char Recv();
}
```

上述Modem的定义中，将拨号连接和将数据通讯的职责混合在一起，这种设计就存在僵化的味道。

一个职责分离的设计是：

![](.\image\figure_8.3_multi_responsibility_modem.PNG)

持久化是另外一种容易违背单一职责的场景。例如，Employee类包含业务规则和持久化控制，业务规则往往会频繁变化，而持久化的方式却不会如此频繁地变化。他们变化的原因也是不一样的。

![](.\image\figure_8.4_persistence_emp.PNG)

测试驱动开发常常能够在设计出现臭味之前就迫使我们分离者两种职责。

#### 2.3 小结

SRP是最简单的原则之一，也是最难应用的原则之一。把职责放到一起是我们很自然的选择。但是，软件设计更应该真正关注的是发现和分离职责。

### 3.开闭原则（OCP）

#### 3.1 什么是开闭原则

定义：

>  软件实体（类、模块、方法等）应该对扩展开放，但是对修改关闭。

- 对扩展开发（Open for extension）

> 当需求变化时，我们可以对模块进行扩展，让它具备满足变化需求的新行为。

- 对修改关闭（Closed for modification）

> 对模块进行扩展时，不用改变系统原有的源代码和二进制代码。

如果正确应用OCP，那么我们就可以通过添加代码，而不是修改已有代码来增加新功能。

#### 3.2 关键在于抽象

一个模块如果依赖于一个固定抽象，那么他可以对于更改可以是关闭的，同时通过创建新的派生类，模块的行为也是可以扩展的。

例如，如果Client类和Server类都是具体类，那么以下实现就是违背开闭原则的。

![](.\image\figure_9.2_client_server_violate_ocp.PNG)

根据OCP，如果Client类想使用不同Server类，那么就需要抽取一个ClientInterface类，并提供不同服务器实现。

![](.\image\figure_9.2_client_server_follow_ocp.PNG)

上述方式使用了策略模式。

#### 3.3 面临的难题

开闭原则面临的难题就在于不可能完全实现，因为总会有一些无法封闭的变化。采用一定的策略来预测变化，然而预置设计又会导致不必要的复杂性。（坏味道）

因此，我们需要采用一些手段来刺激变化，变化越早发生，对我们就越有利。

- 先写测试：保证系统可测，建立可测的抽象，即使变化发生也能泰然处之。
- 使用短的迭代周期进行开发。
- 经常把功能特性展示给参与人员看。
- 尽早、经常发布软件。

#### 3.4 小结

OCP是面向对象设计的核心所在，遵循这个原则可以带来灵活性、可重用性和可维护性。当然，对应用程序中每一个部分都进行抽象也不行，应该只对频繁变化的部分进行抽象。拒绝不成熟的抽象和抽象本身同等重要。

### 4.里氏替换原则（LSP）

#### 4.1 什么是里氏替换原则

定义：

> 派生类（子类型）必须能够替换掉他们的基类（父类型）

假设有一个方法f，它的参数类型为基类B。类型D是类型B的派生类。如果将类型D的对象传入方法f会导致错误的行为。这就表明D的设计违背了LSP。

#### 4.2 一个违背LSP的例子

```c++
void DrawShape(const Shape& s)
{
 if (typeid(s) == typeid(Square))
   DrawSquare(static_cast<Square&>(s));
 else if (typeid(s) == typeid(Circle))
   DrawCircle(static_cast<Circle&>(s));
}
```

这里假设Squre和Circle类都是Shape类的子类，子类不能代替父类，所以违背了LSP。

另外，DrawShape方法就违背了OCP，因为它必须知道所有Shape的子类，新增Shape子类时必须修改DrawShape方法。

#### 4.3 IS-A是关于行为的

在考虑一个方案是否有效时，要根据方案的使用者所作出的合理解释来判断。

例如：

```c++
class Rectangle
{
   public:
          virtual void SetWidth(double w) {itsWidth=w;}
          virtual void SetHeight(double h) {itsHeight=h;}
          double GetHeight() const {return itsHeight;}
          double GetWidth() const {return itsWidth;}
   private:
          double itsHeight;
          double itsWidth;
};
class Square : public Rectangle
{
   public:
          virtual void SetWidth(double w);
          virtual void SetHeight(double h);
};
void Square::SetWidth(double w)
{
    Rectangle::SetWidth(w);
    Rectangle::SetHeight(w);
}
void Square::SetHeight(double h)
{
    Rectangle::SetHeight(h);
    Rectangle::SetWidth(h);
}
```

```c++
void g(Rectangle& r)
{
   r.SetWidth(5);
   r.SetHeight(4);
   assert(r.GetWidth() * r.GetHeight()) == 20);
}
```

对于方法g而言，如果传入对象是Rectangle，那么方法正确运行。但是，如果传入的对象是Square就会发生错误。针对g而言，Square不能替代Rectangle，所以他们之间的关系违背了LSP。

#### 4.4 基于契约的设计

当通过基类的接口使用对象时，用户只知道基类的前置条件和后置条件。因此，派生类对象不能期望用户遵循比基类更强的前置条件。也就是说，派生类必须接受基类可以接受的一切。同时，派生类必须和基类的所有后置条件一致。也就是说，他们的行为方式和输出不能违法基类已经确立的任何限制。基类的用户不能被派生类输出干扰。

#### 4.5 小结

OCP是OOD中很多说法的核心。如果OCP应用有效，应用程序就会有更强的可维护性、可复用性和健壮性。LSP是让OCP成为可能的主要原则之一。正是子类型的可替换性，才使得使用基类类型的模块在无需修改的情况下就可以扩展。这种可替代性必须是开发人员可以隐氏依赖的东西。

IS-A的正确定义是“可替代”，可替代性通过显示或者隐式的契约来定义。

### 5.依赖倒置原则（DIP）

#### 5.1 什么是依赖倒置原则

定义：

> 高层次的模块不应该依赖低层次的模块。两者都应该依赖于抽象。
>
> 抽象不应该依赖于细节，细节应该依赖于抽象。

在传统的软件开发中，高层次模块依赖于低层次模块，策略依赖于细节的软件结构。高层次模块依赖于低层次模块。当低层次模块发生变化时，高层次模块被迫变更。这种设计是荒谬的，它完全违背了高层次模块的内涵。

在面向对象的设计中，因为具体依赖于抽象，其依赖层次结构相比传统软件是“倒置”了。

#### 5.2 层次

Booch曾经说过：“所有结构良好的面向对象的架构都具有清晰定义的层次，每个层次通过一个定义良好的、受控的接口向外提供一组内聚的服务。” 对这句话的理解导致出现下图中的层次结构。

![](.\image\figure_11.2_layer.PNG)

Policy使用低层次的Mechanism层次，而Mechanism使用更细节的Utility层次。

每一个较高的层次都为所需要的服务声明了一个接口，较低层次实现了这些抽象的接口，每个高层次的类都通过该接口使用下一层，这样高层次就不依赖于低层次。

#### 5.3 倒置接口所有权

倒置的不单是依赖关系，还有接口所有权。

我们通常认为工具库拥有他们自己的接口，但是，应用了DIP后，我们发现往往是客户端拥有抽象接口，相关的服务从这些抽象接口派生。

这就是著名的好莱坞原则：“Don't call us, we'll call you.”

通过倒置的所有权，Policy层次就不会被Mechanism层次或者Utility层次的任何改动所影响。

通过倒置依赖关系，我们创建了一个更灵活、更持久、更易变的结构。

#### 5.4 依赖于抽象 

根据DIP，程序中所有的依赖关系都应该止于抽象类或者接口：

- 任何变量都不应该持有具体类的指针或者引用；
- 任何类都不应该继承自具体类；
- 任何子类的方法都不应该覆盖其基类中已经实现了的方法；

上述规则总会被违背，例如针对一些具体但稳定的类型，如String，但是依赖于稳定的类型并不会造成损害，因此也是可以接受的。

#### 5.5 小结

使用任何语言编写程序都无关紧要，如果程序的依赖关系是倒置的，那么它就包含面向对象的设计；如果程序的依赖关系没有倒置，那么它就包含面向过程的设计。

依赖倒置原则是实现很多面向对象设计的基本底层机制，它的正确应用对于创建适应变化的代码是非常重要的。

### 6.接口隔离原则（ISP）

#### 6.1 什么是接口隔离原则

定义：

> 客户端程序不应该被迫依赖于他们不需要的方法，即接口定义的粒度应该足够小

如果一个客户端依赖于一个类中部分方法，而另外一个客户端依赖于这个类中的其他方法，那么这个客户端就会被其它客户端所施加的作用力影响。这就导致了不同的客户端程序存在潜在的耦合。

#### 6.2 接口污染示例

假如有一个安全系统，在这个系统中有一些门（Door）对象，他们可以被锁住或者打开。现在我们需要实现一个TimedDoor，如果门开着时间过长，它就会发出告警。因此，TimeDoor对象需要和一个名为Timer的对象交互。

```java
public interface Door {
    void Lock();
    void Unlock();
    boolean IsDoorOpen();
}
public class Timer {
    public void Register(int timeout, TimeClient client){
        ...
    }
}
public interface TimeClient {
    void TimeOut();
}
```

![](.\image\figure_12.1_timmer.PNG)

这个设计存在接口污染问题。因为Door类依赖于TimedClient，但是不是所有的Door都需要定时功能。然而此时所有Door的派生类都需要实现TimerClient的方法。

#### 6.3 分离客户端就是分离接口

我们考虑软件中带来变化的作用力时，通常考虑的都是接口的变化会怎样影响他们的使用者。然而，还存在另外一个方向的作用力，这就是使用者迫使接口改变的作用力。

在Timer的例子中，如果要避免TimeDoor被重复注册，Timer可以要求每个TimerClient提供一个唯一ID。但是这个改动会影响到TimerClient的所有用户，Door和其派生类都受到了影响。

但是大部分Door不需要定时的功能，这就是僵化和粘性的坏味道。

#### 6.4 类接口和对象接口

一个对象的客户端程序不需要通过这个对象的接口来访问，相反，他们可以通过委托或者该对象的基类来访问。

**通过委托来隔离**

一种解决方案是创建一个从TimerClient继承的对象并把他委托为TimedDoor。

![](.\image\figure_12.2_timeddoor.PNG)

这种做法符合ISP并且也阻止了Door的客户端程序和Timer之间的耦合。

**通过使用多重继承来隔离**

我们可以让TimedDoor同时继承Door和TimerClient，这样客户端就可以使用隔离的接口来方法同一个对象。

![](.\image\figure_12.3_multi_inheritance.PNG)

#### 6.5 小结

Fat Class会导致其客户端程序之间出现古怪且有害的耦合关系。通过将Fat Class分解为多个特定的客户端程序接口，就可以解除客户端程序和他们不需要的接口之间的依赖，让客户端程序之间互相独立。

### 7.重用发布等价原则（REP）

#### 7.1 什么是发布等价原则

定义：

> 重用的粒度就是发布粒度

#### 7.2 如何理解重用发布等价原则

REP原则指出我们在系统中可以复用的粒度必须小于可以发布的包。

由于代码的可复用性必须基于包，因此可复用的包自然必须包含可复用的类。

设计软件包的内部结构时，我们需要从包的使用者的角度出发。

一个软件包，要么其中所有类都可以复用，要么其中所有的类都不可以复用。

### 8.共同重用原则（CRP）

#### 8.1 什么是共同重用原则

定义：

> 同一个软件包中的类可以一起被重用

#### 8.2 如何理解共同重用原则

如果你要复用包中的某一个类，那么就可能要复用包中所有的类。

倾向于一同被复用的类应该被放进同一个软件包中。

没有一定的依赖关系的类不应该被放在同一个软件包中。

### 9.共同封闭原则（CCP）

#### 9.1 什么是共同封闭原则

定义：

> 一个包中的类对于同一类型的变化应该是共同封闭的。对一个包的更改会影响该包中的所有类，而不会影响其他包。

#### 9.2 如何理解共同封闭原则

CCP是单一职责原则对于包级别的体现。

CCP告诉我们一个包不应该有多个可被改变的原因。

CCP原则鼓励我们把可能把可能具有多个变化原因的类聚集在相同地方。这样能够减少发布、重新验证和重新发行的工作量。

CCP原则和开闭原则具有紧密联系。

### 10.无循环依赖原则（SDP）

#### 10.1 什么是理解无循环依赖原则

定义：

> 包之间的依赖关系图中不应该出现环形

#### 10.2 如何理解无循环依赖原则

无循环依赖，就是指软件包结构是一个有向无环图。

![](.\image\figure_20.1_dag.PNG)

如果包之间存在循环依赖，开发人员之间的工作就会存在依赖，从而使得集成和测试变得越来越困难。

#### 10.3 消除循环依赖

消除循环依赖有两个主要的方法：

1. 应用依赖倒置原则（DIP）；
2. 新建一个双方都依赖的包，将依赖部分移动到这个公共的依赖包中；

对于不同的软件包之间的循环依赖，我们可以考虑：

1. 让每个软件包在开发环境独立发布，使用方可以自由决定使用新包还是旧包；
2. 在面临频繁的需求变化时，避免一开始就做自上而下的设计，根据系统功能变化逐步拆分出软件包。

### 11.稳定依赖原则（SAP）

#### 11.1 什么是稳定依赖原则

定义：

> 包依赖应该向着稳定的方向进行

#### 11.2 如何理解稳定依赖原则

对于一个软件包，如果我们期望他是易变的，就不应该让一个不可变的包对他产生依赖。

包的稳定性可以通过出和入的依赖数量来计算：

Ca：依赖于该包的包的数量

Ce：该包依赖的包的数量

I：不稳定性

公式：

> I=Ce/(Ca+Ce)

I=0代表最稳定，I=1代表最不稳定。

例如，下图中包Pc的稳定性I=1/4

![](.\image\figure_20.7_tab.PNG)

并非所有的包都要是稳定的，否则一个系统就不可变了。理想情况下，我们期望设计出一种包结构，使得一些包处于稳定状态，一些包处于不稳定状态。

### 12.稳定抽象原则（SAP）

#### 12.1 什么是稳定抽象原则

定义：

> 包的抽象程度应该和稳定程度一致

#### 12.2 如何理解稳定抽象原则

稳定的包也应该是抽象的，这样它的稳定性就不会阻碍它的继续拓展。

不稳定的包应该是具体的，因为不稳定性可以是其内部代码更容易改变。

SAP和DIP是一致的，因为他们都要求依赖朝着稳定的方向进行。

抽象性度量：

Na--包中的抽象类总数，Nc--包中类总数，A--抽象程度，那么：

A=Na/Nc

A=0以为着没有任何抽象类，A=1以为着只有抽象类。