# 设计模式精粹

## 1. 概述
### 1.1  什么是设计模式？
设计模式使人们可以更加简单方便地复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。

**定义：**

设计模式是描述类和对象之间的沟通方式，这种方式用于解决特定上下文中的特定设计问题。

### 1.2. 设计模式的结构
设计模式由4个基本元素构成：
1. **名称（pattern name）**
一个用于地描述设计问题、解决方案和结果的形象比喻，通常只有一两个词。
2. **问题（problem）**
描述要解决的问题，以及问题的上下文。
3. **解决方案（solution）**
描述组成解决方案的成员，以及他们的关系、职责和协作方式。
4. **结果（consequence）**
描述解决方案带来的利弊，便于评估和选择合适的方案。

### 1.3. 设计模式的分类
设计模式分为3类：
1. **创建型模式（Creational Pattern)**

  创建型模式抽象了实例化过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。

2. **结构型模式（Structural Pattern)**

  结构型模式涉及到如何组合类和对象以获得更大的结构。结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能的一些方法。因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的。

3. **行为型模式（Behavioral Pattern)**

  行为模式涉及到算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。这些模式刻划了在运行时难以跟踪的复杂的控制流。它们将你的注意力从控制流转移到对象间的联系方式上来。

  

## 2. 创建型模式

### 2.1 抽象工厂（ Abstract Factory）

**意图**
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**适用性**
在以下情况可以使用Abstract Factory模式：

- 一个系统要独立于它的产品的创建、组合和表示时。
- 一个系统要由多个产品系列中的一个来配置时。
- 当你要强调一系列相关的产品对象的设计以便进行联合使用时。
- 当你提供一个产品类库，而只想显示它们的接口而不是实现时。

**效果**
 Abstract Factory 模式有下面的一些优点和缺点：

1. **它分离了具体的类**
   抽象工厂模式帮助你控制一个应用创建的对象的类。因为一个工厂封装创建产品对象的责任和过程，它将客户与类的实现分离。客户通过它们的抽象接口操纵实例。产品的类名也在具体工厂的实现中被分离；它们不出现在客户代码中。
2. **它使得易于交换产品系列**
   一个具体工厂类在一个应用中仅出现一次—即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。在我们的用户界面的例子中，我们仅需转换到相应的工厂对象并重新创建接口，就可实现从Motif窗口组件转换为PresentationManager窗口组件。
3. **它有利于产品的一致性**
   当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而 Abstract Factory 很容易实现这一点。
4. **难以支持新种类的产品** 
   难以扩展抽象工厂以生产新种类的产品。这是因为Abstract Factory 接口确定了可以被创建的产品集合。支持新种类的产品就需要扩展该工厂接口，
   这将涉及 Abstract Factory 类及其所有子类的改变。我们会在实现一节讨论这个问题的一个解决办法。

**结构**

![](.\image\GoF-Design-Patterns-Creational-Patterns-Abstract-Factory.png)

**实现**
实现AbstractFactor模式的一些有用技术：
1. **将工厂作为单例** 
   一个应用中一般每个产品系列只需一个ConcreteFactory的实例。因此工厂通常最好实现为一个Singleton。
2. **创建产品**
   Abstract Factory 仅声明一个创建产品的接口，真正创建产品是由ConcreteProduct子类实现的。最通常的一个办法是为每一个产品定义一个工厂方法（参见Factory Method ）。一个具体的工厂将为每个产品重定义该工厂方法以指定产品。虽然这样的实现很简单，但它却要求每个产品系列都要有一个新的具体工厂子类，即使这些产品系列的差别很小。
3. **定义可扩展的工厂**
   Abstract Factory 通常为每一种它可以生产的产品定义一个操作。产品的种类被编码在操作型构中。增加一种新的产品要求改变 Abstract Factory 的接口以及所有与它相关的类。一个更灵活但不太安全的设计是给创建对象的操作增加一个参数。该参数指定了将被创建的对象的种类。它可以是一个类标识符、一个整数、一个字符串，或其他任何可以标识这种产品的东西。

**示例**

假设我们要生产一台计算机（广义的），一台计算机有一些共同的物件。小型计算机（以手机为例）需要有触控屏、微处理器和小型化的内存条。大型计算机（以PC机为例）需要有显示屏、多核处理器和内存条。计算机的各个部件存在着相互依赖关系。

![1564555583691](image/1564555583691.png)

![1564555614102](image/1564555614102.png)



### 2.2  生成器（Builder）

**意图**

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

**适用性**

在以下情况使用 Builder 模式：
- 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
- 当构造过程必须允许被构造的对象有不同的表示时。

**结构**

![](.\image\GoF-Design-Patterns-Creational-Patterns-Builder.png)


**参与者**

- Builder
  为创建一个Product对象的各个部件指定抽象接口。

- ConcreteBuilder
  实现Builder的接口以构造和装配该产品的各个部件。
  定义并明确它所创建的表示。
  提供一个检索产品的接口。

- Director
  构造一个使用Builder接口的对象。

- Product
  表示被构造的复杂对象。ConcreteBuilder 创建该产品的内部表示并定义它的装配过程。
  包含定义组成部件的类，包括将这些部件装配成最终产品的接口。

**协作**

- 客户创建Director对象，并用它所想要的Builder对象进行配置。
- 一旦产品部件被生成，导向器就会通知生成器。
- 生成器处理导向器的请求，并将部件添加到该产品中。
- 客户从生成器中检索产品。

下面的交互图说明了Builder和Director是如何与一个客户协作的：

![1564478906505](image/1564478906505.png)

**效果**

Builder模式的主要效果：

- **它使你可以改变一个产品的内部表示** 
  Builder对象提供给导向器一个构造产品的抽象接口。该接口使得生成器可以隐藏这个产品的表示和内部结构。它同时也隐藏了该产品是如何装配的。因为产品是通过抽象接口构造的，你在改变该产品的内部表示时所要做的只是定义一个新的生成器。

- **它将构造代码和表示代码分开**
  Builder模式通过封装一个复杂对象的创建和表示方式提高了对象的模块性。客户不需要知道定义产品内部结构的类的所有信息；这些类是不出现在Builder接口中的。每个ConcreteBuilder包含了创建和装配一个特定产品的所有代码。这些代码只需要写一次；然后不同的Director可以复用它以在相同部件集合的基础上构作不同的Product。

- **它使你可对构造过程进行更精细的控制**
  Builder模式与一下子就生成产品的创建型模式不同，它是在导向者的控制下一步一步构造产品的。仅当该产品完成时导向者才从生成器中取回它。因此Builder接口相比其他创建型模式能更好的反映产品的构造过程。这使你可以更精细的控制构建过程，从而能更精细的控制所得产品的内部结构。

**实现**
通常有一个抽象的Builder类为导向者可能要求创建的每一个构件定义一个操作。这些操作缺省情况下什么都不做。一个ConcreteBuilder类对它有兴趣创建的构件重定义这些操作。

- **装配和构造接口**
  生成器逐步的构造它们的产品。因此Builder类接口必须足够普遍，以便为各种类型的具体生成器构造产品。
  一个关键的设计问题在于构造和装配过程的模型。构造请求的结果只是被添加到产品中，通常这样的模型就已足够了。

- **为什么产品没有抽象类**
  通常情况下，由具体生成器生成的产品，它们的表示相差是如此之大以至于给不同的产品以公共父类没有太大意思。
- 在**Builder**中缺省的方法为空
  
  C++中，生成方法故意不声明为纯虚成员函数，而是把它们定义为空方法，这使客户只重定义他们所感兴趣的操作。

**示例**
模拟电脑的生产或者组装

![1564555131466](image/1564555131466.png)

### 2.3 工厂方法（Factory Method）

**意图**

定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使一个类的实例化延迟到其子类。

**适用性**
在下列情况下可以使用Factory Method模式：

- 当一个类不知道它所必须创建的对象的类的时候。
- 当一个类希望由它的子类来指定它所创建的对象的时候。
- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

**参与者**

**Product**（产品）参与者

- 定义工厂方法所创建的对象的接口。

**Concrete Product**（具体产品）参与者

- 实现Product接口。

**Creator**（生产者）参与者

- 声明工厂方法，该方法返回一个Product类型的对象。Creator也可以定义一个工厂方
  法的缺省实现，它返回一个缺省的ConcreteProduct对象。
- 可以调用工厂方法以创建一个Product对象。

**Concrete Creator**（具体生产者）参与者

- 重定义工厂方法以返回一个ConcreteProduct实例。

**效果**

1. **为子类提供挂钩**（hook）

   用工厂方法在一个类的内部创建对象通常比直接创建对象更灵活。FactoryMethod给子类一个挂钩以提供对象的扩展版本。

2. **连接平行的类层次** 

   工厂方法并不往往只是被Creator调用，客户可以找到一些有用的工厂方法，尤其在平行类层次的情况下。当一个类将它的一些职责委托给一个独立的类的时候，就产生了平行类层次。

**结构**

![](.\image\GoF-Design-Patterns-Creational-Patterns-Factory-Method-1.png)

**实现**

1. **主要有两种不同的情况** 

   Factory Method 模式主要有两种不同的情况： 

   - 第一种情况是，Creator 类是一个抽象类并且不提供它所声明的工厂方法的实现。 
   - 第二种情况是，Creator 是一个具体的类而且为工厂方法提供一个缺省的实现。也有可能有一个定义了缺省实现的抽象类，但这不太常见。

   第一种情况需要子类来定义实现，因为没有合理的缺省实现。它避免了不得不实例化不可预见类的问题。

   在第二种情况中，具体的 Creator 主要因为灵活性才使用工厂方法。它所遵循的准则是，“用一个独立的操作创建对象，这样子类才能重定义它们的创建方式。”这条准则保证了子类的设计者能够在必要的时候改变父类所实例化的对象的类。

2. **参数化工厂方法** 

   该模式的另一种情况使得工厂方法可以创建多种产品。工厂方法采用一个标识要被创建的对象种类的参数。工厂方法创建的所有对象将共享 Product 接口。

3. **特定语言的变化和问题**

   不同的语言有助于产生其他一些有趣的变化和警告（ caveat）。

4. **使用模板以避免创建子类**

   工厂方法另一个潜在的问题是它们可能仅为了创建适当的Product对象而迫使你创建Creator子类。

5. **命名约定**

   使用命名约定是一个好习惯，它可以清楚地说明你正在使用工厂方法。

**示例**

创建一个身份证
![1564554979515](image/1564554979515.png)

### 2.4  原型模式（Prototype）

**意图**
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**适用性**
- 当一个系统应该独立于它的产品创建、构成和表示时
- 当要实例化的类是在运行时刻指定时，例如，通过动态装载
- 为了避免创建一个与产品类层次平行的工厂类层次时
- 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

**参与者**

- Prototype: 声明一个克隆自身的接口。
- ConcretePrototype:实现一个克隆自身的操作。
- Client:让一个原型克隆自身从而创建一个新的对象。

**协作**
客户请求一个原型克隆自身。

**效果**

Prototype有许多和AbstractFactory（3.1）和Builder（3.2）一样的效果：它对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目。

此外，这些模式使客户无需改变即可使用与特定应用相关的类。

**结构**

![](.\image\GoF-Design-Patterns-Creational-Patterns-Prototype.png)

**实现**

当实现原型时，要考虑下面一些问题：

1. **使用一个原型管理器**

   当一个系统中原型数目不固定时（也就是说，它们可以动态创建和销毁），要保持一个可用原型的注册表。

   客户不会自己来管理原型，但会在注册表中存储和检索原型。

   客户在克隆一个原型前会向注册表请求该原型。我们称这个注册表为原型管理器（prototypemanager）。

   原型管理器是一个关联存储器（associativestore），它返回一个与给定关键字相匹配的原型。它有一些操作可以用来通过关键字注册原型和解除注册。客户可以在运行时更改甚或浏览这个注册表。这使得客户无需编写代码就可以扩展并得到系统清单。

2. **实现克隆操作**

   Prototype模式最困难的部分在于正确实现Clone操作。当对象结构包含循环引用时，这尤为棘手。大多数语言都对克隆对象提供了一些支持。浅拷贝简单并且通常也足够了，但克隆一个结构复杂的原型通常需要深拷贝，因为复制对象和原对象必须相互独立。因此你必须保证克隆对象的构件也是对原型的构件的克隆。克隆迫使你决定如果所有东西都被共享了该怎么办。如果系统中的对象提供了Save和Load操作，那么你只需通过保存对象和立刻载入对象，就可以为Clone操作提供一个缺省实现。Save操作将该对象保存在内存缓冲区中，而Load则通过从该缓冲区中重构这个对象来创建一个复本。

3. **初始化克隆对象**

   当一些客户对克隆对象已经相当满意时，另一些客户将会希望使用他们所选择的一些值来初始化该对象的一些或是所有的内部状态。
   一般来说不可能在Clone操作中传递这些值，因为这些值的数目由于原型的类的不同而会有所不同。
   在Clone操作中传递参数会破坏克隆接口的统一性。
   
   

**示例**
登记形式的原型模式, 这种形式涉及到四个角色：

1. **客户（Client）角色**

   客户类提出创建对象的请求。

2. **抽象原型（Prototype）角色**

   这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。

3. **具体原型（Concrete Prototype）角色**

   被复制的对象。此角色需要实现抽象的原型角色所要求的接口。

4. **原型管理器（PrototypeManager）角色**

   创建具体原型类的对象，并记录每一个被创建的对象。

![1564743219656](image/1564743219656.png)

### 2.5  单例模式（Singleton）

**意图**
保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**动机**
对一些类来说，只有一个实例是很重要的。但怎么样才能保证一个类只有一个实例并且这个实例易于被访问呢？一个全局变量使得一个对象可以被访问，但它不能防止你实例化多个对象。

一个更好的办法是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。这就是 Singleton 模式。

**适用性**
在下面的情况下可以使用 Singleton 模式：

- 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
- 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。

**结构**

![](.\image\GoF-Design-Patterns-Creational-Patterns-Singleton.png)

**示例一：双重校验锁法（通常线程安全，低概率不安全）**

在并发时，双重校验锁法会有怎样的情景：

1. 线程A访问getInstance()方法，因为单例还没有实例化，所以进入了锁定块。

2. 线程B访问getInstance()方法，因为单例还没有实例化，得以访问接下来代码块，而接下来代码块已经被线程1锁定。

3. 线程A进入下一判断，因为单例还没有实例化，所以进行单例实例化，成功实例化后退出代码块，解除锁定。

4. 线程B进入接下来代码块，锁定线程，进入下一判断，因为已经实例化，退出代码块，解除锁定。

5. 线程A获取到了单例实例并返回，线程B没有获取到单例并返回Null。

理论上双重校验锁法是线程安全的，并且，这种方法实现了lazyloading。

**示例二：双重校验锁法（volatile版）**

volatile关键字的一个作用是禁止指令重排，把instance声明为volatile之后，对它的写操作就会有一个内存屏障。

这样，在它的赋值完成之前，就不用会调用读操作。

注意：volatile阻止的不singleton = newSingleton()这句话内部[1-2-3]的指令重排，而是保证了在一个写操作（[1-2-3]）完成之前，不会调用读操作（if (instance == null)）。
也就彻底防止了示例一中的问题发生。

### 2.6  创建型模式的总结

用一个系统创建的那些对象的类对系统进行参数化有两种常用方法：

- **生成创建对象的类的子类**

  这对应于使用 工厂方法（Factory Method） 模式。这种方法的主要缺点是，仅为了改变产品类，就可能需要创建一个新的子类。
  这样的改变可能是级联的（cascade）。
  例如，如果产品的创建者本身是由一个工厂方法创建的，那么你也必须重定义它的创建者。

- **对系统进行参数化的方法更多的依赖于对象复合**
  
  定义一个对象负责明确产品对 象的类，并将它作为该系统的参数。
  这是 抽象工厂（AbstractFactory）、生成器（Builder） 和 原型模式（Prototype）模式的关键特征。
  所有这三个模式都涉及到创建一个新的负责创建产品对象的“工厂对象”：
  
  - 抽象工厂（AbstractFactory）由这个工厂对象产生多个类的对象。
  - 生成器（Builder）由这个工厂对象使用一个相对复杂的协议，逐步创建一个复杂产品。
  - 原型模式（Prototype）由该工厂对象通过拷贝原型对象来创建产品对象。在这种情况下，因为原型负责返回产品对象，所以工厂对象和原型是同一个对象。

  使用抽象工厂（AbstractFactory）、原型模式（Prototype）或生成器（Builder）的设计甚至比使用工厂方法（FactoryMethod）的那些设计更灵活，但它们也更加复杂。

  通常，设计以使用工厂方法（FactoryMethod）开始，并且当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。

  当你在设计标准之间进行权衡的时候，了解多个模式可以给你提供更多的选择余地。



## 3. 结构型模式

### 3.1  适配器模式（Adapter Pattern）

**意图**
将一个类的接口转换成客户希望的另外一个接口。
Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**适用性**

以下情况使用 Adapter 模式：

- 你想使用一个已经存在的类，而它的接口不符合你的需求。
- 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。
- （仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。

**结构**

![](.\image\GoF-Design-Patterns-Structural-Patterns-Adapter.png)

**参与者**

-	**Target**
定义Client使用的与特定领域相关的接口。
-	**Client**
与符合Target接口的对象协同。
-	**Adaptee**
定义一个已经存在的接口，这个接口需要适配。
-	**Adapter**

​       对Adaptee的接口与Target接口进行适配。

**协作**
client在Adapter实例上调用一些操作。接着适配器调用Adaptee的操作实现这个请求。

**效果**

类适配器和对象适配器有不同的权衡。

- 类适配器

1. 用一个具体的Adapter类对Adaptee和Target进行匹配。结果是当我们想要匹配一个类以及所有它的子类时，类Adapter将不能胜任工作。
2. 使得Adapter可以重定义Adaptee的部分行为，因为Adapter是Adaptee的一个子类。
3. 仅仅引入了一个对象，并不需要额外的指针以间接得到Adaptee。

- 对象适配器

1. 允许一个Adapter与多个Adaptee—即Adaptee本身以及它的所有子类（如果有子类的话）同时工作。Adapter也可以一次给所有的Adaptee添加功能。
2. 使得重定义Adaptee的行为比较困难。这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。

- 考虑的其他因素

1. **Adapter 的匹配程度**

   对Adaptee的接口与Target的接口进行匹配的工作量各个Adapter可能不一样。工作范围可能是，从简单的接口转换(例如改变操作名)到支持完全不同的操作集合。Adapter的工作量取决于Target接口与Adaptee接口的相似程度。

2. **可插入的 Adapter**

   当其他的类使用一个类时，如果所需的假定条件越少，这个类就更具可复用性。如果将接口匹配构建为一个类，就不需要假定对其他的类可见的是一个相同的接口。也就是说，接口匹配使得我们可以将自己的类加入到一些现有的系统中去，而这些系统对这个类的接口可能会有所不同。

3. **使用双向适配器提供透明操作**

   使用适配器的一个潜在问题是，它们不对所有的客户都透明。被适配的对象不再兼容Adaptee的接口，因此并不是所有Adaptee对象可以被使用的地方它都可以被使用。双向适配器提供了这样的透明性。在两个不同的客户需要用不同的方式查看同一个对象时，双向适配器尤其有用。


**示例一：类适配器模式**

- **Target**：

  定义Client使用的与特定领域相关的接口。

- **Adaptee**：

  定义一个已经存在的接口，这个接口需要适配。

- **Adapter**：

  对Adaptee的接口与Target接口进行适配。

- **ExampleMain：

  与符合Target接口的对象协同。

![1565349393507](./image/1565349393507.png)

** 示例二：对象适配器模式**

- **Target**：

  定义Client使用的与特定领域相关的接口。

- **Adaptee.java**：

  定义一个已经存在的接口，这个接口需要适配。

- **Adapter**：

  对Adaptee的接口与Target接口进行适配。

- **ExampleMain**：

  与符合Target接口的对象协同。

![1565349509338](./image/1565349509338.png)



### 3.2  桥接模式（Bridge Pattern）

**意图**
将抽象部分与它的实现部分分离，使它们都可以独立地变化。

**动机**
当一个抽象可能有多个实现时，通常用继承来协调它们。抽象类定义对该抽象的接口，而具体的子类则用不同方式加以实现。

但是此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。

**适用性**
以下一些情况使用Bridge模式:
-	你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。
-	类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。
-	对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。
-	（C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。
-	你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。

**结构**

![](.\image\GoF-Design-Patterns-Structural-Patterns-Bridge.png)

**参与者**

- **Abstraction**

  定义抽象类的接口。维护一个指向Implementor类型对象的指针。
  
- **RefinedAbstraction**

  扩充由Abstraction定义的接口。

- **Implementor**

  定义实现类的接口，该接口不一定要与Abstraction的接口完全一致；事实上这两个接口可以完全不同。
  

一般来讲，Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作。

- **ConcreteImplementor**

  实现Implementor接口并定义它的具体实现。

**协作**

Abstraction将client的请求转发给它的Implementor对象。

** 使用场景 **

- **不希望或不适用使用继承的场景**

  例如继承层次过渡、无法更细化设计颗粒等场景，需要考虑使用桥梁模式。

- **接口或抽象类不稳定的场景**

  明知道接口不稳定还想通过实现或继承来实现业务需求，那是得不偿失的，也是比较失败的做法。

- **重用性要求较高的场景**

  设计的颗粒度越细，则被重用的可能性就越大，而采用继承则受父类的限制，不可能出现太细的颗粒度。

**效果**
Bridge模式有以下一些优点：

1. **分离接口及其实现部分**

   一个实现未必不变地绑定在一个接口上。抽象类的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现。

   将Abstraction与Implementor分离有助于降低对实现部分编译时刻的依赖性，当改变一个实现类时，并不需要重新编译Abstraction类和它的客户程序。为了保证一个类库的不同版本之间的二进制兼容性，一定要有这个性质。

   另外，接口与实现分离有助于分层，从而产生更好的结构化系统，系统的高层部分仅需知道Abstraction和Implementor即可。

2. **提高可扩充性**

   你可以独立地对Abstraction和Implementor层次结构进行扩充。

3. **实现细节对客户透明**

   你可以对客户隐藏实现细节，例如共享Implementor对象以及相应的引用计数机制（如果有的话）。

**示例一：通用源代码**

- Abstraction——抽象化角色

  它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。

- Implementor——实现化角色Pattern42_Bridge/src/main/java/com/jueee/example01/Implementor.java)

  它是接口或者抽象类，定义角色必需的行为和属性。

- Refined Abstraction——修正抽象化角色

  它引用实现化角色对抽象化角色进行修正。

- Concrete Implementor——具体实现化角色
  

它实现接口或抽象类定义的方法和属性。


![1565612018171](image/1565612018171.png)

![1565695371156](image/1565695371156.png)

### 3.3 组合模式（Composite）

**意图**
将对象组合成树形结构以表示“**部分-整体**”的层次结构。
Composite 使得用户对单个对象和组合对象的使用具有一致性。

**适用性**
以下情况使用 Composite 模式:
-	你想表示对象的部分-整体层次结构。
-	你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

**结构**

![](.\image\GoF-Design-Patterns-Structural-Patterns-Composite-1.png)

**参与者**
-	**Component**：组件对象
	-	为组合中的对象声明接口。
	-	在适当的情况下，实现所有类共有接口的缺省行为。
	-	声明一个接口用于访问和管理Composite 的子组件。
	-	(可选)在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它。
-	**Leaf**：叶子对象
	-	在组合中表示叶节点对象，叶节点没有子节点。
	-	在组合中定义图元对象的行为。
-	**Composite**：组合对象
	-	定义有子部件的那些部件的行为。
	-	存储子部件。
	-	在Composite 接口中实现与子部件有关的操作。
-	**Client**：客户端
	-	通过Composite 接口操纵组合部件的对象。

**协作**
用户使用Component类接口与组合结构中的对象进行交互：

- 如果接收者是一个叶节点，则直接处理请求。
- 如果接收者是Composite，它通常将请求发送给它的子部件，在转发请求之前与/或之后可能执行一些辅助操作。

**效果**

- **定义了包含基本对象和组合对象的类层次结构**

  基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断的递归下去。客户代码中，任何用到基本对象的地方都可以使用组合对象。

- **简化客户代码**

  客户可以一致地使用组合结构和单个对象。通常用户不知道(也不关心)处理的是一个叶节点还是一个组合组件。这就简化了客户代码,因为在定义组合的那些类中不需要写一些充斥着选择语句的函数。

- **使得更容易增加新类型的组件**

  新定义的Composite或Leaf子类自动地与已有的结构和客户代码一起工作，客户程序不需因新的Component类而改变。

- **使你的设计变得更加一般化**

  容易增加新组件也会产生一些问题，那就是很难限制组合中的组件。有时你希望一个组合只能有某些特定的组件。使用Composite时，你不能依赖类型系统施加这些约束，而必须在运行时刻进行检查。

示例一：商品类别树的管理

-	**Component**：组件对象
-	**Leaf**：叶子对象
-	**[Composite]**：组合对象
-	**ExampleMain**：客户端

![1565698632203](image/1565698632203.png)


### 3.4  装饰者模式（Decorator）

**意图**
动态地给一个对象添加一些额外的职责。
就增加功能来说，Decorator模式相比生成子类更为灵活。

**适用性**

-	在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
-	处理那些可以撤消的职责。
-	当不能采用生成子类的方法进行扩充时。
  - 情况一：可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。
  - 情况二：可能是因为类定义被隐藏，或类定义不能用于生成子类。

**结构**

![](.\image\GoF-Design-Patterns-Structural-Patterns-Decorator.png)

**参与者**

- **Component**：抽象构件角色

  定义一个对象接口，可以给这些对象动态地添加职责。

- **ConcreteComponent**：具体构件角色（真实对象）

  定义一个对象，可以给这个对象添加一些职责。

- **Decorator**：装饰角色

  维持一个指向Component对象的指针，并定义一个与Component接口一致的接口。

-	**ConcreteDecorator**：具体装饰角色

向组件添加职责。

**协作**

Decorator将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作。

**实现**

使用Decorator模式时应注意以下几点：

- **接口的一致性**

  装饰对象的接口必须与它所装饰的Component的接口是一致的，因此，所有的ConcreteDecorator类必须有一个公共的父类。

- **省略抽象的Decorator类**

  当你仅需要添加一个职责时，没有必要定义抽象Decorator类。

- **保持Component类的简单性**

  为了保证接口的一致性，组件和装饰必须有一个公共的Component父类。因此保持这个类的简单性是很重要的；即，它应集中于定义接口而不是存储数据。对数据表示的定义应延迟到子类中，否则Component类会变得过于复杂和庞大，因而难以大量使用。赋予Component太多的功能也使得，具体的子类有一些它们并不需要的功能的可能性大大增加。

- **改变对象外壳与改变对象内核**

  我们可以将Decorator看作一个对象的外壳，它可以改变这个对象的行为。另外一种方法是改变对象的内核。

**示例**

- **Component**：抽象构件角色
- **ConcreteComponent**：具体构件角色（真实对象）
- **Decorator**：装饰角色
- **ConcreteDecoratorA**、**[ConcreteDecoratorB.java]**：具体装饰角色

![1565773984146](image/1565773984146.png)

![1565773463280](image/1565773463280.png)

经典示例：典型的装饰者I/O

java.io 包内的类很多都是装饰者：

![1565774712189](image/1565774712189.png)



### 3.5  外观模式（Facade）

**意图**

为子系统中的一组接口提供一个一致的界面， Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

**动机**

将一个系统划分成为若干个子系统有利于降低系统的复杂性。
一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小。
达到该目标的途径之一是就是引入一个外观（Facade）对象，它为子系统中较一般的设施提供了一个单一而简单的界面。

**适用性**

- 当你要为一个复杂子系统提供一个简单接口时。

  子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。
  这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。
  Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过facade层。

- 客户程序与抽象类的实现部分之间存在着很大的依赖性。

  引入facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。

- 当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。

  如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系。

**结构**

![](.\image\GoF-Design-Patterns-Structural-Patterns-Facade.png)

**参与者**

-	**Facade**
	-	知道哪些子系统类负责处理请求。
	-	将客户的请求代理给适当的子系统对象。
-	**Subsystem classes**
	-	实现子系统的功能。
	-	处理由 Facade 对象指派的任务。
	-	没有 Facade 的任何相关信息；即没有指向 facade 的指针。


**协作**

- 客户程序通过发送请求给Facade的方式与子系统通讯，Facade将这些消息转发给适当的子系统对象。

  尽管是子系统中的有关对象在做实际工作，但Facade模式本身也必须将它的接口转换成子系统的接口。

- 使用Facade的客户程序不需要直接访问子系统对象。

**实现**

使用Facade模式时需要注意以下几点：

1. **降低客户-子系统之间的耦合度**

   用抽象类实现Facade而它的具体子类对应于不同的子系统实现，这可以进一步降低客户与子系统的耦合度。

   这样，客户就可以通过抽象的Facade类接口与子系统通讯。这种抽象耦合关系使得客户不知道它使用的是子系统的哪一个实现。

   除生成子类的方法以外，另一种方法是用不同的子系统对象配置Facade对象。为定制facade，仅需对它的子系统对象（一个或多个）进行替换即可。

2. **公共子系统类与私有子系统类**

   一个子系统与一个类的相似之处是，它们都有接口并且它们都封装了一些东西—类封装了状态和操作，而子系统封装了一些类。

   考虑一个类的公共和私有接口是有益的，我们也可以考虑子系统的公共和私有接口。

   子系统的公共接口包含所有的客户程序可以访问的类；私有接口仅用于对子系统进行扩充。当然，Facade类是公共接口的一部分，但它不是唯一的部分，子系统的其他部分通常也是公共的。

**示例**

- SubSystemA:子系统
- SubSystemB:子系统
- SubSystemC:子系统
- Facade:外观

![1565849325007](image/1565849325007.png)

### 3.6  享元模式（Flyweight）

**意图**

运用共享技术有效地支持大量细粒度的对象。

**动机**

Flyweight模式描述了如何共享对象，使得可以细粒度地使用它们而无需高昂的代价。
flyweight是一个共享对象，它可以同时在多个场景(context)中使用，并且在每个场景中flyweight都可以作为一个独立的对象—这一点与非共享对象的实例没有区别。
flyweight不能对它所运行的场景做出任何假设，这里的关键概念是内部状态和外部状态之间的区别。

- 内部状态存储于flyweight中，它包含了独立于flyweight场景的信息，这些信息使得flyweight可以被共享。
- 外部状态取决于Flyweight场景，并根据场景而变化，因此不可共享。用户对象负责在必要的时候将外部状态传递给Flyweight。

**适用性**

Flyweight 模式的有效性很大程度上取决于如何使用它以及在何处使用它。

当以下情况都成立时使用 Flyweight 模式：

-	一个应用程序使用了大量的对象。
-	完全由于使用大量的对象，造成很大的存储开销。
-	对象的大多数状态都可变为外部状态。
-	如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
-	应用程序不依赖于对象标识。由于 Flyweight 对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。

**结构**

![](.\image\GoF-Design-Patterns-Structural-Patterns-Flyweight.png)

**参与者**

-	**Flyweight**：抽象享元角色
	
	-	描述一个接口，通过这个接口flyweight可以接受并作用于外部状态。
-	**ConcreteFlyweight**：具体享元对象角色
	
	实现Flyweight接口，并为内部状态（如果有的话）增加存储空间。ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的。
	
	即它必须独立于ConcreteFlyweight对象的场景。
	
- **UnsharedConcreteFlyweight**：复合享元角色

  并非所有的Flyweight子类都需要被共享。

  Flyweight接口使共享成为可能，但它并不强制共享。

  在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点（Row和Column就是这样）。
-	**FlyweightFactory**：享元工厂角色
	
	-	创建并管理flyweight对象。
	-	确保合理地共享flyweight。当用户请求一个flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。
-	**Client**：客户端
	
	-	维持一个对flyweight的引用。
	-	计算或存储一个（多个）flyweight的外部状态。

**协作**

- flyweight执行时所需的状态必定是内部的或外部的。

  内部状态存储于ConcreteFlyweight对象之中；而外部对象则由Client对象存储或计算。

  当用户调用flyweight对象的操作时，将该状态传递给它。

-	用户不应直接对ConcreteFlyweight类进行实例化，而只能从FlyweightFactory对象得到ConcreteFlyweight对象，这可以保证对它们适当地进行共享。

**实现**

在实现Flyweight模式时，注意以下几点：
- **删除外部状态**

  该模式的可用性在很大程度上取决于是否容易识别外部状态并将它从共享对象中删除。

  如果不同种类的外部状态和共享前对象的数目相同的话，删除外部状态不会降低存储消耗。

  理想的状况是，外部状态可以由一个单独的对象结构计算得到，且该结构的存储要求非常小。

- **管理共享对象**

  因为对象是共享的，用户不能直接对它进行实例化，因此FlyweightFactory可以帮助用户查找某个特定的Flyweight对象。

  共享还意味着某种形式的引用计数和垃圾回收，这样当一个Flyweight不再使用时，可以回收它的存储空间。

  然而，当Flyweight的数目固定而且很小的时候（例如，用于ACSII码的Flyweight），这两种操作都不必要。在这种情况下，Flyweight完全可以永久保存。

**示例一：通用源代码** 

- Flyweight：抽象享元角色

- ConcreteFlyweight：具体享元对象角色

- UnsharedConcreteFlyweight：复合享元角色

- FlyweightFactory：享元工厂角色

- ExampleMain：客户端

![1565857047589](image/1565857047589.png)

### 3.7  代理模式（Proxy）

**意图**

为其他对象提供一种代理以控制对这个对象的访问。

**动机**

对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。

我们考虑一个可以在文档中嵌入图形对象的文档编辑器。有些图形对象（如大型光栅图像）的创建开销很大。但是打开文档必须很迅速，因此我们在打开文档时应避免一次性创建所有开销很大的对象。因为并非所有这些对象在文档中都同时可见，所以也没有必要同时创建这些对象。

这一限制条件意味着，对于每一个开销很大的对象，应该根据需要进行创建，当一个图像变为可见时会产生这样的需要。

问题的解决方案是使用另一个对象，即图像Proxy，替代那个真正的图像。

Proxy可以代替一个图像对象，并且在需要时负责实例化这个图像对象。

**适用性**

在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。

下面是一些可以使用Proxy模式常见情况：

- **远程代理**（Remote Proxy）
  为一个对象在不同的地址空间提供局部代表。

- **虚代理**（Virtual Proxy）
  根据需要创建开销很大的对象。
  
- **保护代理**（Protection Proxy）
  控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。

- **缓冲代理**（Cache Proxy）：
  为一个目标的操作结果开辟一个临时的空间存储，以便多个客户端共享使用。

- **智能指引**（Smart Reference）
	取代了简单的指针，它在访问对象时执行一些附加操作。
	

它的典型用途包括：

	-	对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它。
	-	当第一次引用一个持久对象时，将它装入内存。
	-	在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。

**结构**

![](.\image\GoF-Design-Patterns-Structural-Patterns-Proxy.png)

**参与者**

-	**Proxy**：代理主题角色
	-	保存一个引用使得代理可以访问实体。若RealSubject和Subject的接口相同，Proxy会引用Subject。
	-	提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体。
	-	控制对实体的存取，并可能负责创建和删除它。
	-	其他功能依赖于代理的类型：
		-	**Remote Proxy**负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求。
		-	**Virtual Proxy**可以缓存实体的附加信息，以便延迟对它的访问。
		-	**Protection Proxy**检查调用者是否具有实现一个请求所必需的访问权限。
-	**Subject**：抽象主题角色
	-	定义RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。
-	**RealSubject**：真实主题角色
	-	定义Proxy所代表的实体。

** 协作**
代理根据其种类，在适当的时候向`RealSubject`转发请求。

** 示例一：静态代理**

代理类接受一个Subject接口的对象，任何实现该接口的对象，都可以通过代理类进行代理，增加了通用性。

但是也有缺点：

- 每一个代理类都必须实现一遍委托类（也就是realsubject）的接口，如果接口增加方法，则代理类也必须跟着
- 代理类每一个接口对象对应一个委托对象，如果委托对象非常多，则静态代理类就非常臃肿，难以胜任。

示例代码：

- ProxySubject：代理主题角色
- Subject：抽象主题角色
- RealSubject：真实主题角色
- ExampleMain：测试类

![1565866423707](image/1565866423707.png)

** 示例二：动态代理**

动态代理有别于静态代理，是根据代理的对象，动态创建代理类。
这样，就可以避免静态代理中代理类接口过多的问题。
动态代理是实现方式，是通过反射来实现的，借助Java自带的`java.lang.reflect.Proxy`,通过固定的规则生成。

![1565867280197](image/1565867280197.png)

**示例三：Cglib代理**

![1565868086979](image/1565868086979.png)

### 3.8  结构型模式的总结

结构型模式依赖于同一个很小的语言机制集合构造代码和对象：单继承和多重继承机制用于基于类的模式，而对象组合机制用于对象式模式。

模式间的差异非常重要，因为它们针对了面向对象设计过程中一些特定的经常发生问题的解决方法。但这并不意味着这些模式不能结合使用。



**Adapter与Bridge**

适配器模式（Adapter）和 桥接模式（Bridge）具有一些共同的特征。

- 它们都给另一对象提供了一定程度上的间接性，因而有利于系统的灵活性。
- 它们都涉及到从自身以外的一个接口向这个对象转发请求。

这些模式的不同之处主要在于它们各自的用途：

- **适配器模式（Adapter）主要是为了解决两个已有接口之间不匹配的问题。**

  它不考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化。这种方式不需要对两个独立设计的类中的任一个进行重新设计，就能够使它们协同工作。
  
- **桥接模式（Bridge）则对抽象接口与它的（可能是多个）实现部分进行桥接。**

  虽然这一模式允许你修改实现它的类，它仍然为用户提供了一个稳定的接口。Bridge模式也会在系统演化时适应新的实现。




由于这些不同点，Adapter和Bridge模式通常被用于软件生命周期的不同阶段。

当你发现两个不兼容的类必须同时工作时，就有必要使用适配器模式（Adapter），其目的一般是为了避免代码重复。此处耦合不可预见。

相反，桥接模式（Bridge）的使用者必须事先知道：一个抽象将有多个实现部分，并且抽象和实现两者是独立演化的。

适配器模式（Adapter）在类已经设计好后实施；而桥接模式（Bridge）在设计类之前实施。

这并不意味着Adapter模式不如Bridge模式，只是因为它们针对了不同的问题。



**Composite与Decorator**
组合模式（Composite）和 装饰模式（Decorator）模式具有类似的结构图，这说明它们都基于递归组合来组织可变数目的对象。

这一共同点可能会使你认为，decorator对象是一个退化的composite，但这一观点没有领会Decorator模式要点。

相似点仅止于递归组合，同样，这是因为这两个模式的目的不同。

- 装饰者模式（Decorator）旨在使你能够不需要生成子类即可给对象添加职责。这就避免了静态实现所有功能组合，从而导致子类急剧增加。
- 组合模式（Composite）则有不同的目的，它旨在构造类，使多个相关的对象能够以统一的方式处理，而多重对象可以被当作一个对象来处理。它重点不在于修饰，而在于表示。

尽管它们的目的截然不同，但却具有互补性。因此Composite和Decorator模式通常协同使用。在使用这两种模式进行设计时，我们无需定义新的类，仅需将一些对象插接在一起即可构建应用。

这时系统中将会有一个抽象类，它有一些composite子类和decorator子类，还有一些实现系统的基本构建模块。此时，composites和decorator将拥有共同的接口。

从装饰模式（Decorator）的角度看，composite是一个ConcreteComponent。而从组合模式（Composite）的角度看，decorator则是一个Leaf。



**Decorator与Proxy**
装饰模式（Decorator）和 代理模式（Proxy）结构相似。

这两种模式都描述了怎样为对象提供一定程度上的间接引用，proxy和decorator对象的实现部分都保留了指向另一个对象的指针，
它们向这个对象发送请求。

然而同样，它们具有不同的设计目的。

像装饰模式（Decorator）一样，代理模式（Proxy）构成一个对象并为用户提供一致的接口。但与装饰模式（Decorator）不同的是，代理模式（Proxy）不能动态地添加或分离性质，它也不是为递归组合而设计的。它的目的是，当直接访问一个实体不方便或不符合需要时，为这个实体提供一个替代者，例如，实体在远程设备上，访问受到限制或者实体是持久存储的。

- 在代理模式（Proxy）中，实体定义了关键功能，而Proxy提供（或拒绝）对它的访问。

- 在装饰模式（Decorator）中，组件仅提供了部分功能，而一个或多个Decorator负责完成其他功能。Decorator模式适用于编译时不能（至少不方便）确定对象的全部功能的情况。

## 4. 行为型模式

### 4.1  责任链模式（Chain of Responsibility）

**意图**

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

**适用性**

在以下条件下使用 Responsibility 链：
-	有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。
-	你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
-	可处理一个请求的对象集合应被动态指定。

**结构**

![](.\image\GoF-Design-Patterns-Behavioral-Patterns-Chain-of-Responsibility.png)

**参与者**

-	**Handler**：抽象处理者
	-	定义一个处理请求的接口。
	-	（可选）实现后继链。
-	**ConcreteHandler**：具体处理者
	-	处理它所负责的请求。
	-	可访问它的后继者。
	-	如果可处理该请求，就处理之；否则将该请求转发给它的后继者。
-	**Client**：客户端
	- 向链上的具体处理者(ConcreteHandler)对象提交请求。

**协作**

当客户提交一个请求时，请求沿链传递直至有一个ConcreteHandler对象负责处理它。

**效果**

Responsibility链有下列优点和缺点(liabilities):

- **降低耦合度**

  该模式使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需知道该请求会被“正确”地处理。
  接收者和发送者都没有对方的明确的信息，且链中的对象不需知道链的结构。
  结果是，职责链可简化对象的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。

- **增强了给对象指派职责(Responsibility)的灵活性**

  当在对象中分派职责时，职责链给你更多的灵活性。
  你可以通过在运行时刻对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。你可以将这种机制与静态的特例化处理对象的继承机制结合起来使用。

- **不保证被接受**

  既然一个请求没有明确的接收者，那么就不能保证它一定会被处理—该请求可能一直到链的末端都得不到处理。
  一个请求也可能因该链没有被正确配置而得不到处理。

**示例一：请假条的审批过程**

公司里面，请假条的审批过程：
-	如果请假天数小于3天，主任审批
-	如果请假天数大于等于3天，小于10天，经理审批
-	如果大于等于10天，小于30天，总经理审批
-	如果大于等于30天，提示拒绝

![1565925979863](image/1565925979863.png)

示例代码：

- **Data**：抽象数据封装
  
  - [LeaveRequest.java](Pattern501_ChainOfResponsibility/src/main/java/com/jueee/example01/LeaveRequest.java)：封装请假的相关信息
  
- **Handler**：抽象处理者
  
  - [Leader.java](Pattern501_ChainOfResponsibility/src/main/java/com/jueee/example01/Leader.java)：领导的抽象类
  
- **ConcreteHandler**：具体处理者
  - Director：主任的实现类
  -	Manager：经理的实现类
  -	ViceGeneralManager：副总经理的实现类
  -	GeneralManager：总经理的实现类


![1565934690848](image/1565934690848.png)

### 4.2 命令模式（Command）

**意图**
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。

**动机**

有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接受者的任何信息。
命令模式通过将请求本身变成一个对象来使工具箱对象可向未指定的应用对象提出请求。这个对象可被存储并像其他的对象一样被传递。
这一模式的关键是一个抽象的Command类，它定义了一个执行操作的接口。
其最简单的形式是一个抽象的Execute操作。
具体的Command子类将接收者作为其一个实例变量，并实现Execute操作，指定接收者采取的动作。而接收者有执行该请求所需的具体信息。

**适用性**

当你有如下需求时，可使用Command模式：
-	抽象出待执行的动作以参数化某对象。可以用过程语言中的回调（callback）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command模式是回调机制的一个面向对象的替代品。
-	在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。
-	支持取消操作。Command的Excute操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command接口必须添加一个Unexecute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。
-	支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。
-	用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务(transaction)的信息系统中很常见。一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。

**结构**

![](.\image\GoF-Design-Patterns-Behavioral-Patterns-Command.png)

**参与者**

-	**Command**：抽象命令，包含命令执行的抽象方法
	-	声明执行操作的接口。
-	**ConcreteCommand**：它包含一个命令接收者对象，并调用接收者的对象相应实现方法。
	-	将一个接收者对象绑定于一个动作。
	-	调用接收者相应的操作，以实现Execute。
-	**Invoker**：提供给客户端调用，接收客户端所传递的具体命令对象。
	-	要求该命令执行这个请求。
-	**Receiver**：命令接收者角色，它包含所有命令的具体行为实现方法。
	-	知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。
-	**Client**：客户端
	-	创建一个具体命令对象并设定它的接收者。

**协作**

-	`Client`创建一个`ConcreteCommand`对象并指定它的Receiver对象。
-	某`Invoker`对象存储该`ConcreteCommand`对象。
-	该`Invoker`通过调用`Command`对象的`Execute`操作来提交一个请求。若该命令是可撤消的，
`ConcreteCommand`就在执行`Excute`操作之前存储当前状态以用于取消该命令。
-	`ConcreteCommand`对象对调用它的`Receiver`的一些操作以执行该请求。

**效果**

Command模式有以下效果:
-	Command模式将调用操作的对象与知道如何实现该操作的对象解耦。
-	Command是头等的对象。它们可像其他的对象一样被操纵和扩展。
-	你可将多个命令装配成一个复合命令。例如是前面描述的MacroCommand类。一般说来，复合命令是Composite模式的一个实例。
-	增加新的Command很容易，因为这无需改变已有的类。

**示例一：通用源代码**

司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。

这个过程好在，三者(司令、命令、士兵)相互解耦，任何一方都不用去依赖其他人的具体实现，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。

-	Command：命令执行的接口
-	ConcreteCommand：具体实现的命令
-	Invoker：调用者（司令员）
-	Receiver：被调用者（士兵）

![1565940294322](image/1565940294322.png)

### 4.3  解释器模式（Interpreter）

**意图**

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

**动机**

如果一种特定类型的问题发生的频率足够高 , 那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器 , 该解释器通过解释这些句子来解决该问题。

解释器模式描述了如何为简单的语言定义一个文法 , 如何在该语言中表示一个句子 , 以及如何解释这些句子。

**适用性**

当有一个语言需要解释执行 , 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。

而当存在以下情况时该模式效果最好：

- **该文法简单**

  对于复杂的文法 , 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式 , 这样可以节省空间而且还可能节省时间。

- **效率不是一个关键问题**

  最高效的解释器通常不是通过直接解释语法分析树实现的 , 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。

**结构**

![](.\image\GoF-Design-Patterns-Behavioral-Patterns-Interpreter.png)

**参与者**

-	**AbstractExpression**（抽象表达式）
	-	声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。
-	**TerminalExpression**（终结符表达式）
	-	实现与文法中的终结符相关联的解释操作。
	-	一个句子中的每个终结符需要该类的一个实例。
-	**NonterminalExpression**（非终结符表达式）
	-	对文法中的每一条规则R::=R1R2...Rn都需要一个`NonterminalExpression`类。
	-	为从R1到Rn的每个符号都维护一个`AbstractExpression`类型的实例变量。
	-	为文法中的非终结符实现解释(`Interpret`)操作。解释(`Interpret`)一般要递归地调用表示R1到Rn的那些对象的解释操作。
-	**Context**（上下文）
	-	包含解释器之外的一些全局信息。
-	**Client**（客户）
	-	构建(或被给定)表示该文法定义的语言中一个特定的句子的抽象语法树。该抽象语法树由`NonterminalExpression`和`TerminalExpression`的实例装配而成。
	-	调用解释操作。

**协作**

-	`Client`构建(或被给定)一个句子,它是`NonterminalExpression`和`TerminalExpression`的实例的一个抽象语法树，然后初始化上下文并调用解释操作。
-	每一非终结符表达式节点定义相应子表达式的解释操作。而各终结符表达式的解释操作构成了递归的基础。
-	每一节点的解释操作用上下文来存储和访问解释器的状态。

**效果**

解释器模式有下列的优点和不足:
- **易于改变和扩展文法**

  因为该模式使用类来表示文法规则 , 你可使用继承来改变或扩展该文法。已有的表达式可被增量式地改变 ，而新的表达式可定义为旧表达式的变体。

- **易于实现文法**

  定义抽象语法树中各个节点的类的实现大体类似。这些类易于直接编写，通常它们也可用一个编译器或语法分析程序生成器自动生成。

- **复杂的文法难以维护**

  解释器模式为文法中的每一条规则至少定义了一个类(使用BNF定义的文法规则需要更多的类)。因此包含许多规则的文法可能难以管理和维护。可应用其他的设计模式来缓解这一问题。但当文法非常复杂时, 其他的技术如语法分析程序或编译器生成器更为合适。

- **增加了新的解释表达式的方式**

  解释器模式使得实现新表达式“计算”变得容易。 例如,你可以在表达式类上定义一个新的操作以支持优美打印或表达式的类型检查。如果你经常创建新的解释表达式的方式, 那么可以考虑使用Visitor模式以避免修改这些代表文法的类。

**示例一：通用源代码**

-	AbstractExpression（抽象表达式）
-	TerminalExpression（终结符表达式）
-	NonterminalExpression（非终结符表达式）

![1566204300213](image/1566204300213.png)

### 4.4  迭代器模式（Iterator）

**意图**

提供一种方法顺序访问一个聚合对象中各个元素 , 而又不需暴露该对象的内部表示。

**动机**

迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器（iterator）对象中。迭代器类定义了一个访问该列表元素的接口。迭代器对象负责跟踪当前的元素，即，它知道哪些元素已经遍历过了。

**适用性**

迭代器模式可用来：
-	访问一个聚合对象的内容而无需暴露它的内部表示。
-	支持对聚合对象的多种遍历。
-	为遍历不同的聚合结构提供一个统一的接口(即,支持多态迭代)。

**结构**

![](.\image\GoF-Design-Patterns-Behavioral-Patterns-Iterator.png)

**参与者**

-	**Iterator**：（迭代器）
	-	迭代器定义访问和遍历元素的接口。
-	**ConcreteIterator**：（具体迭代器）
	-	具体迭代器实现迭代器接口。
	-	对该聚合遍历时跟踪当前位置。
-	**Aggregate**：（聚合）
	-	聚合定义创建相应迭代器对象的接口。
-	**ConcreteAggregate**：（具体聚合）
	-	具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。

**协作**

-	**ConcreteIterator **跟踪聚合中的当前对象，并能够计算出待遍历的后继对象。

**效果**

迭代器模式有三个重要的作用：

- **它支持以不同的方式遍历一个聚合**
  复杂的聚合可用多种方式进行遍历。
  例如 , 代码生成和语义检查要遍历语法分析树。代码生成可以按中序或者按前序来遍历语法分析树。
  迭代器模式使得改变遍历算法变得很容易: 仅需用一个不同的迭代器的实例代替原先的实例即可。
  
- **迭代器简化了聚合的接口**

  有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了。这样就简化了聚合的接口。

- **在同一个聚合上可以有多个遍历**

  每个迭代器保持它自己的遍历状态。因此你可以同时进行多个遍历。

**示例一：通用源代码**

- Iterator：迭代器定义访问和遍历元素的接口。
- ConcreteIterator：具体迭代器实现迭代器接口，并对该聚合遍历时跟踪当前位置。
- Aggregate：聚合定义创建相应迭代器对象的接口。
- ConcreteAggregate：具体聚合实现创建相应迭代器的接口。

![1566898065456](image/1566898065456.png)

### 4.5  中介者模式（Mediator）

**意图**

用一个中介对象来封装一系列的对象交互。
中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的互。

**适用性**

在下列情况下使用中介者模式:
-	一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。
-	一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。
-	想定制一个分布在多个类中的行为，而又不想生成太多的子类。

**结构**

![](.\image\GoF-Design-Patterns-Behavioral-Patterns-Mediator.png)

**参与者**

-	**Mediator**(抽象中介者)
	-	中介者定义一个接口用于与各同事（Colleague）对象通信。
-	**ConcreteMediator**(具体中介者)
	-	具体中介者通过协调各同事对象实现协作行为。
	-	了解并维护它的各个同事。
-	**Colleague**(抽象同事类)
  - 定义出调停者到同事对象的接口。同事对象只知道中介者对象而不知道其余的同事对象。
-	**ConcreteColleague**(具体同事类)
	-	每一个同事类都知道它的中介者对象。
	-	每一个同事对象在需与其他的同事通信的时候，与它的中介者通信。

**协作**

-	同事向一个中介者对象发送和接收请求。中介者在各同事间适当地转发请求以实现协作行为。

**效果**

- **减少了子类生成**

  Mediator将原本分布于多个对象间的行为集中在一起。改变这些行为只需生成Meditator的子类即可。这样各个Colleague类可被重用。

- **它将各Colleague解耦**

  Mediator有利于各Colleague间的松耦合.你可以独立的改变和复用各Colleague类和Mediator类。

- **它简化了对象协议**

  用Mediator和各Colleague间的一对多的交互来代替多对多的交互。一对多的关系更易于理解、维护和扩展。

- **它对对象如何协作进行了抽象将**

  中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。这有助于弄清楚一个系统中的对象是如何交互的。

- **它使控制集中化**

  中介者模式将交互的复杂性变为中介者的复杂性。因为中介者封装了协议,它可能变得比任一个Colleague都复杂。这可能使得中介者自身成为一个难于维护的庞然大物。

**示例一：通用源代码**

- Mediator: 抽象中介者
- ConcreteMediator: 具体中介者)
- Colleague: 抽象同事类
- ConcreteColleagueA: 具体同事类
- ConcreteColleagueB: 具体同事类

![1566898141019](image/1566898141019.png)
![1566898170178](image/1566898170178.png)

### 4.6 备忘录模式（Memento）

**意图**

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

**适用性**

在以下情况下使用备忘录模式：
-	必须保存一个对象在某一个时刻的(部分)状态,这样以后需要时它才能恢复到先前的状态。
-	如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。

**结构**

![](.\image\GoF-Design-Patterns-Behavioral-Patterns-Memento.png)

**参与者**

-	**Memento**：（备忘录）
	
	- 备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态。
	- 防止原发器以外的其他对象访问备忘录。
	
	备忘录实际上有两个接口，管理者(caretaker)只能看到备忘录的窄接口——它只能将备忘录传递给其他对象。相反，原发器能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。
	
-	**Originator**：（原发器）
	
	-	原发器创建一个备忘录,用以记录当前时刻它的内部状态。
	-	使用备忘录恢复内部状态.。
	
-	**Caretaker**：（备忘录管理员角色）
	
	-	负责保存好备忘录。
	-	不能对备忘录的内容进行操作或检查。

**协作**

-	管理器向原发器请求一个备忘录 , 保留一段时间后,将其送回给原发器 , 如下面的交互图所示。

**效果**

备忘录模式有以下一些效果:

- **保持封装边界**
  使用备忘录可以避免暴露一些只应由原发器管理却又必须存储在原发器之外的信息。该模式把可能很复杂的Originator内部信息对其他对象屏蔽起来，从而保持了封装边界。

- **它简化了原发器**
  在其他的保持封装性的设计中，Originator负责保持客户请求过的内部状态版本。这就把所有存储管理的重任交给了Originator。让客户管理它们请求的状态将会简化Originator，并且使得客户工作结束时无需通知原发器。

- **使用备忘录可能代价很高**
  如果原发器在生成备忘录时必须拷贝并存储大量的信息，或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销。除非封装和恢复Originator状态的开销不大，否则该模式可能并不合适。参见实现一节中关于增量式改变的讨论。

- **定义窄接口和宽接口**
  在一些语言中可能难以保证只有原发器可访问备忘录的状态。

- **维护备忘录的潜在代价**
  管理器负责删除它所维护的备忘录。然而，管理器不知道备忘录中有多少个状态。因此当存储备忘录时，一个本来很小的管理器，可能会产生大量的存储开销。

**示例一：通用源代码**

- Memento：备忘录
- Originator：原发器
- Caretaker：备忘录管理员角色

![1567424210382](image/1567424210382.png)

### 4.7  观察者模式（Observer）

**意图**

定义对象间的一种一对多的依赖关系 ,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。

**适用性**

在以下任一情况下可以使用观察者模式:
-	当一个抽象模型有两个方面,其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
-	当对一个对象的改变需要同时改变其它对象,而不知道具体有多少对象有待改变。
-	当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之,你不希望这些对象是紧密耦合的。

**结构**

![](.\image\GoF-Design-Patterns-Behavioral-Patterns-Observer.png)

**参与者**

-	**Subject**（抽象目标）
	-	目标知道它的观察者。可以有任意多个观察者观察同一个目标。
	-	提供注册和删除观察者对象的接口。
-	**Observer**（抽象观察者）
	-	为那些在目标发生改变时需获得通知的对象定义一个更新接口。
-	**ConcreteSubject**（具体目标）
	-	将有关状态存入各ConcreteObserver对象。
	-	当它的状态发生改变时,向它的各个观察者发出通知。
-	**ConcreteObserver**（具体观察者）
	-	维护一个指向ConcreteSubject对象的引用。
	-	存储有关状态，这些状态应与目标的状态保持一致。
	-	实现Observer的更新接口以使自身状态与目标的状态保持一致。

**协作**

-	当ConcreteSubject发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。
-	在得到一个具体目标的改变通知后,ConcreteObserver对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致。

**示例一：订阅微信公众号**

以微信公众号为例，假设微信用户就是观察者，微信公众号是被观察者，有多个微信用户关注了“程序员”这个公众号，当这个公众号更新时就会通知这些订阅的微信用户。

- Subject:  抽象目标
- Observer: 抽象观察者
- SubscriptionSubject：微信公众号
- WeixinUser: 具体观察者, 微信用户

![1567512205454](image/1567512205454.png)

### 4.8 状态模式（State）

**意图**

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

**适用性**

在下面的两种情况下均可使用 State 模式：

-  一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。

- 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。

  这个状态通常用一个或多个枚举常量表示。
  通常,有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。
  这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。

**结构**

![](.\image\GoF-Design-Patterns-Behavioral-Patterns-State.png)

**参与者**

-	**Context**：（环境角色）
	-	定义客户感兴趣的接口。
	-	维护一个ConcreteState子类的实例，这个实例定义当前状态。
-	**State**：（状态角色）
	-	定义一个接口以封装与Context的一个特定状态相关的行为。
-	**ConcreteState subclasses**：（具体状态子类角色）
	-	每一子类实现一个与Context的一个状态相关的行为。

**协作**

-	Context将与状态相关的请求委托给当前的ConcreteState对象处理。
-	Context可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问Context。
-	Context是客户使用的主要接口。客户可用状态对象来配置一个Context，一旦一个Context配置完毕,它的客户不再需要直接与状态对象打交道。
-	Context或ConcreteState子类都可决定哪个状态是另外哪一个的后继者，以及是在何种条件下进行状态转换。

**示例一：通用源代码**

-	Context：环境角色
-	State：状态角色
-	StartState：具体状态子类角色

![1567649330854](image/1567649330854.png)

### 4.9  策略模式（Strategy）

** 意图**

定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

**适用性**

当存在以下情况时使用Strategy模式
-	许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。
-	需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。
-	算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。
-	一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。

**结构**

![](.\image\GoF-Design-Patterns-Behavioral-Patterns-Strategy.png)

**参与者**

-	**Strategy**：（抽象策略角色）
	-	定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。
-	**ConcreteStrategy**：（具体策略角色）
	-	以Strategy接口实现某具体算法。
-	**Context**：（上下文角色）
	-	用一个 ConcreteStrategy 对象来配置。
	-	维护一个对Strategy对象的引用。
	-	可定义一个接口来让Stategy访问它的数据。

**协作**

-	Strategy 和 Context 相互作用以实现选定的算法。当算法被调用时， Context 可以将该算法所需要的所有数据都传递给该 Stategy。或者，Context 可以将自身作为一个参数传递给 Strategy 操作。这就让 Strategy 在需要时可以回调 Context。
-	Context 将它的客户的请求转发给它的 Strategy。客户通常创建并传递一个 ConcreteStrategy 对象给该Context；这样，客户仅与 Context 交互。通常有一系列的 ConcreteStrategy 类可供客户从中选择。

**效果**

Strategy模式有下面的一些优点和缺点:
- **相关算法系列**

  Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。

- **一个替代继承的方法**

  继承提供了另一种支持多种算法或行为的方法。你可以直接生成一个Context类的子类，从而给它以不同的行为。但这会将行为硬行编制到Context中，而将算法的实现与Context的实现混合起来，从而使Context难以理解、难以维护和难以扩展，而且还不能动态地改变算法。最后你得到一堆相关的类，它们之间的唯一差别是它们所使用的算法或行为。将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。

- **消除了一些条件语句**

  Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。当不同的行为堆砌在一个类中时，很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的Strategy类中消除了这些条件语句。

- **实现的选择**

  Strategy 模式可以提供相同行为的不同实现。客户可以根据不同时间/空间权衡取舍要求从不同策略中进行选择。

- **客户必须了解不同的 Strategy**

  本模式有一个潜在的缺点，就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同。此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时，才需要使用Strategy模式。

- **Strategy 和 Context 之间的通信开销**

  无论各个ConcreteStrategy实现的算法是简单还是复杂，它们都共享Strategy定义的接口。因此很可能某些ConcreteStrategy不会都用到所有通过这个接口传递给它们的信息；简单的ConcreteStrategy可能不使用其中的任何信息！这就意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样问题，那么将需要在Strategy和Context之间更进行紧密的耦合。

- **增加了对象的数目**

  Strategy 增加了一个应用中的对象的数目。有时你可以将Strategy实现为可供各Context共享的无状态的对象来减少这一开销。任何其余的状态都由Context维护。Context在每一次对Strategy对象的请求中都将这个状态传递过去。共享的Stragey不应在各次调用之间维护状态。

**示例一：通用源代码**

-	Strategy：抽象策略角色
-	StrategyA、StrategyB、StrategyC：（具体策略角色）
-	Context：（上下文角色）

![1567685723950](image/1567685723950.png)

### 4.10 模板方法模式（Template Method）

** 意图**

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

`Template Method` 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

**适用性**

模板方法应用于下列情况：
-	一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
-	各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。
-	控制子类扩展。模板方法只在特定点调用“hook”操作（参见效果一节），这样就只允许在这些点进行扩展。

**结构**

![](.\image\GoF-Design-Patterns-Behavioral-Patterns-Template-Method.png)



**参与者**

-	**Abstract Class**（抽象类角色）
	-	定义抽象的原语操作（primitiveoperation），具体的子类将重定义它们以实现一个算法的各步骤。
	-	实现一个模板方法,定义一个算法的骨架。该模板方法不仅调用原语操作，也调用定义在AbstractClass或其他对象中的操作。
-	**Concrete Class**（具体类角色）
	-	实现原语操作以完成算法中与特定子类相关的步骤。

**协作**

-	ConcreteClass靠AbstractClass来实现算法中不变的步骤。

**示例一：通用源代码**

-	AbstractClass: 抽象类角色
-	ContreteTemplateA、ContreteTemplateB: 具体类角色

![1568097180225](image/1568097180225.png)

### 4.11  访问者模式（Visitor）

**意图**

表示一个作用于某对象结构中的各元素的操作。
Visitor 模式使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

**适用性**

在下列情况下使用 Visitor 模式：

-	一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。
-	需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。Visitor 使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。
-	定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。

**结构**

![](.\image\GoF-Design-Patterns-Behavioral-Patterns-Visitor.png)

**参与者**

-	**Visitor**（抽象访问者角色）
	-	为该对象结构中ConcreteElement的每一个类声明一个Visit操作。该操作的名字和特征标识了发送Visit请求给该访问者的那个类。这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它。
-	**ConcreteVisitor**（具体访问者角色）
	-	实现每个由Visitor声明的操作。每个操作实现本算法的一部分，而该算法片断乃是对应于结构中对象的类。ConcreteVisitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。
-	**Element**（抽象元素角色）
	-	定义一个Accept操作，它以一个访问者为参数。
-	**ConcreteElement**（具体元素角色）
	-	实现Accept操作，该操作以一个访问者为参数。
-	**ObjectStructure**（对象结构角色）
	-	能枚举它的元素。
	-	可以提供一个高层的接口以允许该访问者访问它的元素。
	-	可以是一个复合或是一个集合，如一个列表或一个无序集合。

**协作**

-	一个使用Visitor模式的客户必须创建一个ConcreteVisitor对象，然后遍历该对象结构，并用该访问者访问每一个元素。
-	当一个元素被访问时，它调用对应于它的类的Visitor操作。如果必要，该元素将自身作为这个操作的一个参数以便该访问者访问它的状态。

**效果**

下面是访问者模式的一些优缺点：
- **访问者模式使得易于增加新的操作**

  访问者使得增加依赖于复杂对象结构的构件的操作变得容易了。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。相反，如果每个功能都分散在多个类之上的话，定义新的操作时必须修改每一类。

- **访问者集中相关的操作而分离无关的操作**

  相关的行为不是分布在定义该对象结构的各个类上，而是集中在一个访问者中。无关行为却被分别放在它们各自的访问者子类中。这就既简化了这些元素的类，也简化了在这些访问者中定义的算法。所有与它的算法相关的数据结构都可以被隐藏在访问者中。

- **增加新的 ConcreteElement 类很困难**

  Visitor 模式使得难以增加新的Element的子类。每添加一个新的ConcreteElement都要在Vistor中添加一个新的抽象操作，并在每一个ConcretVisitor类中实现相应的操作。

- **通过类层次进行访问**

  一个迭代器可以通过调用节点对象的特定操作来遍历整个对象结构，同时访问这些对象。但是迭代器不能对具有不同元素类型的对象结构进行操作。

- **累积状态**

  当访问者访问对象结构中的每一个元素时，它可能会累积状态。如果没有访问者，这一状态将作为额外的参数传递给进行遍历的操作，或者定义为全局变量。

- **破坏封装**

  访问者方法假定 ConcreteElement 接口的功能足够强，足以让访问者进行它们的工作。结果是，该模式常常迫使你提供访问元素内部状态的公共操作，这可能会破坏它的封装性。

**示例一：通用源代码（双重分派）**

数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者则反过来执行节点对象的操作。这样的过程叫做 “**双重分派**”。节点调用访问者，将它自己传入，访问者则将某种算法针对此节点执行。

-	Visitor：抽象访问者角色
-	VisitorA、VisitorB、VisitorCEO：具体访问者角色
-	Element：抽象元素角色）
-	PartA、PartB：具体元素角色
-	ObjectStructure：对象结构角色
-	ExampleMain：测试类

![1568101297817](image/1568101297817.png)
![1568101316288](image/1568101316288.png)

### 4.12  行为型模式的总结

**封装变化**

封装变化是很多行为模式的主题。

当一个程序的某个方面的特征经常发生改变时，这些模式就定义一个封装这个方面的对象。这样当该程序的其他部分依赖于这个方面时，它们都可以与此对象协作。

这些模式通常定义一个抽象类来描述这些封装变化的对象，并且通常该模式依据这个对象来命名。

例如：

- 策略模式（Strategy）：一个 Strategy 对象封装一个算法。
- 状态模式（State）：一个 State 对象封装一个与状态相关的行为。
- 中介者模式（Mediator）：一个 Mediator 对象封装对象间的协议。
- 迭代器模式（Iterator）：一个 Iterator 对象封装访问和遍历一个聚集对象中的各个构件的方法。

这些模式描述了程序中很可能会改变的方面。

大多数模式有两种对象：

- **封装该方面特征的新对象**
- **使用这些新的对象的已有对象**

如果不使用这些模式的话，通常这些新对象的功能就会变成这些已有对象的难以分割的一部分。

例如，一个 Strategy 的代码可能会被嵌入到其 Context 类中，而一个 State 的代码可能会在该状态的 Context 类中直接实现。

但不是所有的对象行为模式都象这样分割功能。

例如，责任链模式（ChainOfResponsibility）可以处理任意数目的对象（即一个链），而所有这些对象可能已经存在于系统中了。职责链说明了行为模式间的另一个不同点：并非所有的行为模式都定义类之间的静态通信关系。职责链提供在数目可变的对象间进行通信的机制。其他模式涉及到一些作为参数传递的对象。

**对象作为参数**

一些模式引入总是被用作参数的对象。

例如访问者模式（Visitor），一个 Visitor 对象是一个多态的 Accept 操作的参数，这个操作作用于该 Visitor 对象访问的对象。虽然以前通常代替 Visitor 模式的方法是将 Visitor 代码分布在一些对象结构的类中，但 visitor 从来都不是它所访问的对象的一部分。

其他模式定义一些可作为令牌到处传递的对象，这些对象将在稍后被调用。命令模（Command）和 备忘录模式（Memento）都属于这一类。在Command中，令牌代表一个请求；而在Memento中，它代表在一个对象在某个特定时刻的内部状态。在这两种情况下，令牌都可以有一个复杂的内部表示，但客户并不会意识到这一点。但这里还有一些区别：在Command模式中多态很重要，因为执行Command对象是一个多态的操作。相反，Memento接口非常小，以至于备忘录只能作为一个值传递。因此它很可能根本不给它的客户提供任何多态操作。

**通信应该被封装还是被分布**

中介者模式（Mediator）和 观察者模式（Observer）是相互竞争的模式。

它们之间的差别是：

- **Observer**通过引入Observer和Subject对象来分布通信。
- **Mediator**对象则封装了其他对象间的通信。

在Observer模式中，不存在封装一个约束的单个对象，而必须是由Observer和Subject对象相互协作来维护这个约束。

通信模式由观察者和目标连接的方式决定：一个目标通常有多个观察者，并且有时一个目标的观察者也是另一个观察者的目标。

Mediator模式的目的是集中而不是分布。它将维护一个约束的职责直接放在一个中介者中。我们发现生成可复用的Observer和Subject比生成可复用的Mediator容易一些。

Observer模式有利于Observer和Subject间的分割和松耦合，同时这将产生粒度更细,从而更易于复用的类。

另一方面，相对于Observer，Mediator中的通信流更容易理解。观察者和目标通常在它们被创建后很快即被连接起来，并且很难看出此后它们在程序中是如何连接的。

**对发送者和接收者解耦**

当合作的对象直接互相引用时，它们变得互相依赖，这可能会对一个系统的分层和重用性产生负面影响。

命令模式（Command）、观察者模式（Observer）、中介者模式（Mediator），和责任链模式（ChainOfResponsibility）等模式都涉及如何对发送者和接收者解耦，但它们又各有不同的权衡考虑。

**命令模式**

命令模式（Command）使用一个Command对象来定义一个发送者和一个接收者之间的绑定关系，从而支持解耦，如下图所示。

![1568114770968](image/1568114770968.png)

Command对象提供了一个提交请求的简单接口（即Execute操作）。将发送者和接收者之间的连接定义在一个单独的对象使得该发送者可以与不同的接收者一起工作。这就将发送者与接收者解耦，使发送者更易于复用。此外，可以复用Command对象，用不同的发送者参数化一个接收者。虽然Command模式描述了避免使用生成子类的实现技术，名义上每一个发送者－接收者连接都需要一个子类。

**观察者模式**

观察者模式（Observer）通过定义一个接口来通知目标中发生的改变，从而将发送者（目标）与接收者（观察者）解耦。Observer定义了一个比Command更松的发送者－接收者绑定，因为一个目标可能有多个观察者，并且其数目可以在运行时变化，如下图所示。

![1568114806457](image/1568114806457.png)

观察者模式中的Subject和Observer接口是为了处理Subject的变化而设计的，因此当对象间有数据依赖时，最好用观察者模式来对它们进行解耦。

**中介者模式**

中介者模式（Mediator）让对象通过一个Mediator对象间接的互相引用，从而对它们解耦，如下图所示。

![1568114821955](image/1568114821955.png)

一个Mediator对象为各Colleague对象间的请求提供路由并集中它们的通信。因此各Colleague对象仅能通过Mediator接口相互交谈。因为这个接口是固定的，为增加灵活性Mediator可能不得不实现它自己的分发策略。可以用一定方式对请求编码并打包参数，使得Colleague对象可以请求的操作数目不限。

中介者模式可以减少一个系统中的子类生成，因为它将通信行为集中到一个类中而不是将其分布在各个子类中。然而，特别的分发策略通常会降低类型安全性。

**责任链模式**

责任链模式（ChainOfResponsibility）通过沿一个潜在接收者链传递请求而将发送者与接收者解耦，如下图所示。

![1568114856712](image/1568114856712.png)

因为发送者和接收者之间的接口是固定的，职责链可能也需要一个定制的分发策略。因此它与Mediator一样存在类型安全的问题。如果职责链已经是系统结构的一部分，同时在链上的多个对象中总有一个可以处理请求，那么职责链将是一个很好的将发送者和接收者解耦的方法。此外，因为链可以被简单的改变和扩展，从而该模式提供了更大的灵活性。

**总结**

除了少数例外情况，各个行为设计模式之间是相互补充和相互加强的关系。

例如，一个职责链中的类可能包括至少一个 模板方法模式（TemplateMethod）的应用。该模板方法可使用原语操作确定该对象是否应处理该请求并选择应转发的对象。职责链可以使用命令模式（Command）将请求表示为对象。

解释器模式（Interpreter）定义语法分析上下文。迭代器可以遍历一个聚合，而访问者可以对它的每一个元素进行一个操作。

行为模式也与能其他模式很好地协同工作。

例如，一个使用 组合模式（Composite）的系统可以使用一个访问者对该复合的各成分进行一些操作：

- 它可以使用职责链使得各成分可以通过它们的父类访问某些全局属性。
- 它可以使用 装饰模式（Decorator）对该复合的某些部分的这些属性进行改写。
- 它可以使用 观察者模式（Observer）将一个对象结构与另一个对象结构联系起来。
- 可以使用 状态模式（State）使得一个构件在状态改变时可以改变自身的行为。
- 复合本身可以使用 生成器（Builder）中的方法创建，并且它可以被系统中的其他部分当作一个 原型模式（Prototype）。

设计良好的面向对象式系统通常有多个模式镶嵌在其中，但其设计者却未必使用这些术语进行思考。

然而，在模式级别而不是在类或对象级别上的进行系统组装可以使我们更方便地获取同等的协同性。








